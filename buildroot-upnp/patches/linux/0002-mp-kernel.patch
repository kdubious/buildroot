diff --git a/sound/soc/codecs/mp.c b/sound/soc/codecs/mp.c
index f6ae0702ce7c..bc507a2f4964 100644
--- a/sound/soc/codecs/mp.c
+++ b/sound/soc/codecs/mp.c
@@ -1,7 +1,9 @@
 /*
- * mp.c - Musica Pristina ALSA SoC codec driver
+ * mp.c -- Musica Pristina ALSA SoC codec driver
  *
- * Copyright 2018 Welsh Technologies.
+ * Copyright 2019 Welsh Technologies.
+ * 
+ * Author: Kevin Welsh <kwelsh@welshtechnologies.com>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -13,13 +15,13 @@
 #include <linux/i2c.h>
 #include <linux/regmap.h>
 #include <linux/of_device.h>
+#include <linux/kernel.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
 #include <sound/soc.h>
 #include "mp.h"
 
-
 static int ocxo = 1;
 module_param(ocxo, int, 0644);
 MODULE_PARM_DESC(ocxo, "Boolean to enable OCXO (0/1 == DFXO/OCXO)");
@@ -30,7 +32,7 @@ MODULE_PARM_DESC(maxrate, "Maximum PCM rate");
 
 /* custom function to fetch info of PCM playback volume */
 static int dac_info_volsw(struct snd_kcontrol *kcontrol,
-						  struct snd_ctl_elem_info *uinfo)
+			  struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
 	uinfo->count = 2;
@@ -43,7 +45,7 @@ static int dac_info_volsw(struct snd_kcontrol *kcontrol,
  * custom function to get PCM playback volume
  */
 static int dac_get_volsw(struct snd_kcontrol *kcontrol,
-						 struct snd_ctl_elem_value *ucontrol)
+			 struct snd_ctl_elem_value *ucontrol)
 {
 	int l;
 	int r;
@@ -61,7 +63,7 @@ static int dac_get_volsw(struct snd_kcontrol *kcontrol,
  * custom function to put PCM playback volume
  */
 static int dac_put_volsw(struct snd_kcontrol *kcontrol,
-						 struct snd_ctl_elem_value *ucontrol)
+			 struct snd_ctl_elem_value *ucontrol)
 {
 	int l;
 	int r;
@@ -72,26 +74,46 @@ static int dac_put_volsw(struct snd_kcontrol *kcontrol,
 	return 0;
 }
 
-static const struct snd_kcontrol_new mp_snd_controls[] = {
-	{
-		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
-		.name = "PCM Playback Volume",
-		.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,
-		.info = dac_info_volsw,
-		.get = dac_get_volsw,
-		.put = dac_put_volsw,
-	},
+static int mp2019_dai_trigger(struct snd_pcm_substream *substream, int cmd,
+			  struct snd_soc_dai *dai)
+{
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		dev_dbg(dai->dev, "Starting audio stream\n");
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		dev_dbg(dai->dev, "Stopping audio stream\n");
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static const unsigned int mp2019_rates[] = {
+	44100,  48000,  88200,  96000,  176400,
+	192000, 352800, 384000, 705600, 768000,
 };
 
-/* set codec format */
-static int mp_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)
+static const struct snd_pcm_hw_constraint_list mp2019_rate_constraints = {
+	.count = ARRAY_SIZE(mp2019_rates),
+	.list = mp2019_rates,
+};
+
+
+
+static int mp2019_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)
 {
-	struct snd_soc_codec *codec = codec_dai->codec;
-	struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
+	struct snd_soc_component *component = dai->component;
+	struct mp2019_codec_priv *mp = snd_soc_component_get_drvdata(component);
 
 	/* I2S clock and frame master setting. */
-	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK)
-	{
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
 	case SND_SOC_DAIFMT_CBM_CFM:
 		break;
 	default:
@@ -99,8 +121,7 @@ static int mp_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)
 	}
 
 	/* setting I2S data format */
-	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK)
-	{
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
 	case SND_SOC_DAIFMT_I2S:
 		break;
 	default:
@@ -111,16 +132,19 @@ static int mp_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)
 	return 0;
 }
 
-/*
- * set clock according to i2s frame clock.
- */
-static int mp_set_clock(struct snd_soc_codec *codec, int frame_rate,
-						int frame_width)
+static int mp2019_hw_params(struct snd_pcm_substream *substream,
+			    struct snd_pcm_hw_params *params,
+			    struct snd_soc_dai *dai)
 {
-	dev_warn(codec->dev, "BEGIN mp_set_clock");
+	int frame_rate, frame_width;
+	struct snd_soc_component *component = dai->component;
 
-	switch (frame_rate)
-	{
+	frame_rate = params_rate(params);
+	frame_width = params_width(params);
+	
+	dev_warn(component->dev, "BEGIN mp2019_set_clock");
+
+	switch (frame_rate) {
 	case 44100:
 	case 48000:
 	case 88200:
@@ -130,384 +154,269 @@ static int mp_set_clock(struct snd_soc_codec *codec, int frame_rate,
 	case 352800:
 	case 384000:
 		break;
-		/*
-#if defined(CONFIG_SND_SOC_MPCODEC_MAXRATE_768)
-#endif
-*/
-
 	case 705600:
 	case 768000:
-		if (maxrate == 768)
-		{
+		if (maxrate == 768) {
 			break;
-		}
-		else
-		{
-			dev_err(codec->dev, "frame rate %d not supported\n",
-					frame_rate);
+		} else {
+			dev_err(component->dev, "frame rate %d not supported\n",
+				frame_rate);
 			return -EINVAL;
 		}
 	default:
-		dev_err(codec->dev, "frame rate %d not supported\n",
-				frame_rate);
+		dev_err(component->dev, "frame rate %d not supported\n",
+			frame_rate);
 		return -EINVAL;
 	}
-	switch (frame_width)
-	{
+	switch (frame_width) {
 	case 16:
 	case 24:
 	case 32:
 		break;
 	default:
-		dev_err(codec->dev, "%d-bit frame width not supported\n", frame_width);
+		dev_err(component->dev, "%d-bit frame width not supported\n",
+			frame_width);
 		return -EINVAL;
 	}
-	/*
-#if defined(CONFIG_SND_SOC_MPCODEC_XTAL_OCXO)
-	dev_warn(codec->dev, "    CONFIG_SND_SOC_MPCODEC_XTAL_OCXO");
-	return update_playback_OCXO(codec, frame_rate, frame_width);
-#elif defined(CONFIG_SND_SOC_MPCODEC_XTAL_DFXO)
-	dev_warn(codec->dev, "    CONFIG_SND_SOC_MPCODEC_XTAL_DFXO");
-	return update_playback_DFXO(codec, frame_rate, frame_width);
-#endif
-*/
-	if (ocxo == 1)
-	{
+	if (ocxo == 1) {
 		/* OCXO crystal strategy */
-		dev_warn(codec->dev, "    CONFIG_SND_SOC_MPCODEC_XTAL_OCXO");
-		return update_playback_OCXO(codec, frame_rate, frame_width);
-	}
-	else
-	{
+		dev_warn(component->dev,
+			 "    CONFIG_SND_SOC_MPCODEC_XTAL_OCXO");
+		return update_playback_OCXO(dai, frame_rate, frame_width);
+	} else {
 		/* Dual Frequency XO crystal strategy */
-		dev_warn(codec->dev, "    CONFIG_SND_SOC_MPCODEC_XTAL_DFXO");
-		return update_playback_DFXO(codec, frame_rate, frame_width);
+		dev_warn(component->dev,
+			 "    CONFIG_SND_SOC_MPCODEC_XTAL_DFXO");
+		return update_playback_DFXO(dai, frame_rate, frame_width);
 	}
 
-	dev_warn(codec->dev, "END mp_set_clock");
+	dev_warn(component->dev, "END mp2019_set_clock");
 	return 0;
 }
 
-/*
- * Set PCM DAI params.
- */
-static int mp_pcm_hw_params(struct snd_pcm_substream *substream,
-							struct snd_pcm_hw_params *params,
-							struct snd_soc_dai *dai)
+static int mp2019_codec_startup(struct snd_pcm_substream *substream,
+			    struct snd_soc_dai *dai)
 {
-	struct snd_soc_codec *codec = dai->codec;
 	int ret;
 
-	ret = mp_set_clock(codec, params_rate(params), params_width(params));
-	if (ret)
-		return ret;
+	ret = snd_pcm_hw_constraint_list(substream->runtime, 0,
+					 SNDRV_PCM_HW_PARAM_RATE,
+					 &mp2019_rate_constraints);
 
-	return 0;
+	return ret;
 }
 
-static int mp_dai_trigger(struct snd_pcm_substream *substream, int cmd,
-						  struct snd_soc_dai *dai)
-{
-	struct snd_soc_codec *codec = dai->codec;
 
-	switch (cmd)
-	{
-	case SNDRV_PCM_TRIGGER_START:
-	case SNDRV_PCM_TRIGGER_RESUME:
-	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
-		dev_dbg(codec->dev, "Starting audio stream\n");
-		break;
-	case SNDRV_PCM_TRIGGER_STOP:
-	case SNDRV_PCM_TRIGGER_SUSPEND:
-	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
-		dev_dbg(codec->dev, "Stopping audio stream\n");
-		break;
-	default:
-		break;
-	}
-
-	return 0;
-}
-/*
-#if defined(CONFIG_SND_SOC_MPCODEC_MAXRATE_384)
-static const unsigned int mp_rates[] = {
-	44100,
-	48000,
-	88200,
-	96000,
-	176400,
-	192000,
-	352800,
-	384000,
-};
-#elif defined(CONFIG_SND_SOC_MPCODEC_MAXRATE_768)
-static const unsigned int mp_rates[] = {
-	44100,
-	48000,
-	88200,
-	96000,
-	176400,
-	192000,
-	352800,
-	384000,
-	705600,
-	768000,
-};
-#endif
-*/
-/*
-#if (maxrate==768)
-*/
-static const unsigned int mp_rates[] = {
-	44100,
-	48000,
-	88200,
-	96000,
-	176400,
-	192000,
-	352800,
-	384000,
-	705600,
-	768000,
+static const struct regmap_config mp2019_lcd_regmap_config = {
+	.reg_bits = 16,
+	.val_bits = 24,
+	.max_register = 0xFFFF,
+	.cache_type = REGCACHE_RBTREE,
 };
-/*#elif (maxrate!=768)
-static const unsigned int mp_rates[] = {
-	44100,
-	48000,
-	88200,
-	96000,
-	176400,
-	192000,
-	352800,
-	384000,
+EXPORT_SYMBOL_GPL(mp2019_lcd_regmap_config);
+
+static const struct regmap_config mp2019_clock_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+	.max_register = 0xFF,
+	.cache_type = REGCACHE_RBTREE,
 };
-#endif
-*/
+EXPORT_SYMBOL_GPL(mp2019_clock_regmap_config);
 
-#define MP_CODEC_FORMATS (SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
-// remove to force 24 / 32 bit conversion
-//SNDRV_PCM_FMTBIT_S16_LE | \
+static const struct regmap_config mp2019_oscsel_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+	.max_register = 0xFF,
+	.cache_type = REGCACHE_RBTREE,
+};
+EXPORT_SYMBOL_GPL(mp2019_oscsel_regmap_config);
 
+static const struct snd_soc_dai_ops mp2019_dai_ops = {
+	.startup = mp2019_codec_startup,
+	.hw_params = mp2019_hw_params,
+	.set_fmt = mp2019_set_dai_fmt,
+	.trigger = mp2019_dai_trigger,
+};
 
-#define MP_CODEC_RATES (SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 |   \
-						SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 |   \
-						SNDRV_PCM_RATE_176400 | SNDRV_PCM_RATE_192000 | \
-						SNDRV_PCM_RATE_352000 | SNDRV_PCM_RATE_384000 | \
-						SNDRV_PCM_RATE_705600 | SNDRV_PCM_RATE_768000)
+static const struct snd_kcontrol_new mp2019_controls[] = {
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "PCM Playback Volume",
+		.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,
+		.info = dac_info_volsw,
+		.get = dac_get_volsw,
+		.put = dac_put_volsw,
+	},
+};
 
-static const struct snd_pcm_hw_constraint_list mp_rate_constraints = {
-	.count = ARRAY_SIZE(mp_rates),
-	.list = mp_rates,
+static struct snd_soc_dai_driver mp2019_dai = {
+	.name = "Musica Pristina",
+	.playback =
+		{
+			.stream_name = "Playback",
+			.channels_min = 2,
+			.channels_max = 2,
+			.rates = SNDRV_PCM_RATE_KNOT,
+			.formats = MP2019_FORMATS,
+		},
+	.ops = &mp2019_dai_ops,
 };
 
-static int mp_codec_startup(struct snd_pcm_substream *substream,
-							struct snd_soc_dai *dai)
+
+/*
+int mp2019_common_init(struct device *dev, struct regmap *regmap)
 {
-	int ret;
+	struct mp2019_private *mp2019;
 
-	ret = snd_pcm_hw_constraint_list(substream->runtime, 0,
-									 SNDRV_PCM_HW_PARAM_RATE, &mp_rate_constraints);
+	mp2019 = devm_kzalloc(dev, sizeof(struct mp2019_private), GFP_KERNEL);
+	if (!mp2019)
+		return -ENOMEM;
 
-	return ret;
+	mp2019->regmap = regmap;
+	dev_set_drvdata(dev, mp2019);
+
+	return devm_snd_soc_register_component(dev, &soc_component_dev_mp2019,
+					       &mp2019_dai, 1);
 }
+EXPORT_SYMBOL_GPL(mp2019_common_init);
+*/
 
-static const struct snd_soc_dai_ops mp_codec_ops = {
-	.startup = mp_codec_startup,
-	.hw_params = mp_pcm_hw_params,
-	.set_fmt = mp_set_dai_fmt,
-	.trigger = mp_dai_trigger,
-};
 
-static struct snd_soc_dai_driver mp_dai = {
-	/*
-#if defined(CONFIG_SND_SOC_MPCODEC_MAXRATE_384)
-#if defined(CONFIG_SND_SOC_MPCODEC_XTAL_OCXO)
-	.name = "Musica Pristina 384 OCXO",
-#elif defined(CONFIG_SND_SOC_MPCODEC_MAXRATE_768)
-	.name = "Musica Pristina 384 DFXO",
-#endif
-#elif defined(CONFIG_SND_SOC_MPCODEC_MAXRATE_768)
-#if defined(CONFIG_SND_SOC_MPCODEC_XTAL_OCXO)
-	.name = "Musica Pristina 768 OCXO",
-#elif defined(CONFIG_SND_SOC_MPCODEC_MAXRATE_768)
-	.name = "Musica Pristina 768 DFXO",
-#endif
-#endif
-*/
-	.name = "Musica Pristina",
-	.playback = {
-		.stream_name = "Playback",
-		.channels_min = 2,
-		.channels_max = 2,
-		.rates = SNDRV_PCM_RATE_KNOT,
-		.formats = MP_CODEC_FORMATS,
-	},
-	.ops = &mp_codec_ops,
-};
 
-static int mp_codec_probe(struct snd_soc_codec *codec)
+static int mp2019_codec_probe(struct snd_soc_component *component)
 {
 	return 0;
 }
 
-static int mp_codec_remove(struct snd_soc_codec *codec)
+static void mp2019_codec_remove(struct snd_soc_component *component)
 {
-	return 0;
 }
 
-static struct snd_soc_codec_driver mp_codec_driver = {
-	.probe = mp_codec_probe,
-	.remove = mp_codec_remove,
-	.component_driver = {
-		.controls = mp_snd_controls,
-		.num_controls = ARRAY_SIZE(mp_snd_controls),
-	},
+static const struct snd_soc_component_driver soc_component_dev_mp2019 = {
+	.probe = mp2019_codec_probe,
+	.remove = mp2019_codec_remove,
+	.controls = mp2019_controls,
+	.num_controls = ARRAY_SIZE(mp2019_controls),
+	.idle_bias_on = 1,
+	.use_pmdown_time = 1,
+	.endianness = 1,
+	.non_legacy_dai_naming = 1,
 };
 
-/* LCD DRIVER */
-
-static const struct regmap_config mp_lcd_regmap = {
-	.reg_bits = 16,
-	.val_bits = 24,
-
-	.max_register = 0xFFFF,
 
-	.cache_type = REGCACHE_RBTREE,
-};
+/* LCD DRIVER */
 
-static int mp_lcd_i2c_probe(struct i2c_client *client,
-							const struct i2c_device_id *id)
+static int mp2019_lcd_i2c_probe(struct i2c_client *i2c,
+			    const struct i2c_device_id *id)
 {
 	struct device_node *clkgen_np;
 	struct i2c_client *clkgen_client;
-	struct mp_codec_priv *mp;
+	struct mp2019_codec_priv *mp;
 	int ret;
 
-	dev_warn(&client->dev, "BEGIN mp_lcd_i2c_probe");
+	dev_warn(&i2c->dev, "BEGIN mp2019_lcd_i2c_probe");
 
-	clkgen_np = of_parse_phandle(client->dev.of_node, "mp,clkgen", 0);
-	if (!clkgen_np)
-	{
-		dev_err(&client->dev, "Failed to get clock generator phandle\n");
+	clkgen_np = of_parse_phandle(i2c->dev.of_node, "mp,clkgen", 0);
+	if (!clkgen_np) {
+		dev_err(&i2c->dev,
+			"Failed to get clock generator phandle\n");
 		return -ENODEV;
 	}
 	clkgen_client = of_find_i2c_device_by_node(clkgen_np);
 	of_node_put(clkgen_np);
-	if (!clkgen_client)
-	{
-		dev_dbg(&client->dev, "Clock generator I2C client not found\n");
+	if (!clkgen_client) {
+		dev_dbg(&i2c->dev, "Clock generator I2C client not found\n");
 		return -EPROBE_DEFER;
 	}
 	mp = i2c_get_clientdata(clkgen_client);
 	put_device(&clkgen_client->dev);
-	mp->lcd_regmap = devm_regmap_init_i2c(client, &mp_lcd_regmap);
-	if (IS_ERR(mp->lcd_regmap))
-	{
+	mp->lcd_regmap = devm_regmap_init_i2c(i2c, &mp2019_lcd_regmap_config);
+	if (IS_ERR(mp->lcd_regmap)) {
 		ret = PTR_ERR(mp->lcd_regmap);
-		dev_err(&client->dev,
-				"Failed to allocate lcd regmap: %d\n", ret);
+		dev_err(&i2c->dev, "Failed to allocate lcd regmap: %d\n",
+			ret);
 		return ret;
 	}
 
-	i2c_set_clientdata(client, mp);
+	i2c_set_clientdata(i2c, mp);
 
-	dev_warn(&client->dev, "END mp_lcd_i2c_probe");
+	dev_warn(&i2c->dev, "END mp2019_lcd_i2c_probe");
 
 	return 0;
 }
 
-static int mp_lcd_i2c_remove(struct i2c_client *client)
+static int mp2019_lcd_i2c_remove(struct i2c_client *i2c)
 {
 	return 0;
 }
 
-static const struct i2c_device_id mp_lcd_id[] = {
-	{"mp_lcd", 0},
-	{},
+static const struct i2c_device_id mp2019_lcd_id[] = {
+	{ "mp2019_lcd", 0 },
+	{ },
 };
 
-MODULE_DEVICE_TABLE(i2c, mp_lcd_id);
+MODULE_DEVICE_TABLE(i2c, mp2019_lcd_id);
 
-static const struct of_device_id mp_lcd_dt_ids[] = {
+static const struct of_device_id mp2019_lcd_dt_ids[] = {
 	{
 		.compatible = "mp,codec-lcd",
 	},
-	{/* sentinel */}};
-MODULE_DEVICE_TABLE(of, mp_lcd_dt_ids);
-
-static struct i2c_driver mp_lcd_i2c_driver = {
-	.driver = {
-		.name = "mp_lcd",
-		.of_match_table = mp_lcd_dt_ids,
-	},
-	.probe = mp_lcd_i2c_probe,
-	.remove = mp_lcd_i2c_remove,
-	.id_table = mp_lcd_id,
+	{ }
 };
+MODULE_DEVICE_TABLE(of, mp2019_lcd_dt_ids);
 
-/* END LCD DRIVER */
-
-static const struct regmap_config mp_codec_regmap = {
-	.reg_bits = 8,
-	.val_bits = 8,
-
-	.max_register = 0xFF,
-
-	.cache_type = REGCACHE_RBTREE,
+static struct i2c_driver mp2019_lcd_i2c_driver = {
+	.driver =
+		{
+			.name = "mp2019_lcd",
+			.of_match_table = mp2019_lcd_dt_ids,
+		},
+	.probe = mp2019_lcd_i2c_probe,
+	.remove = mp2019_lcd_i2c_remove,
+	.id_table = mp2019_lcd_id,
 };
 
-static const struct regmap_config mp_oscsel_regmap = {
-	.reg_bits = 8,
-	.val_bits = 8,
-
-	.max_register = 0xFF,
-
-	.cache_type = REGCACHE_RBTREE,
-};
+/* END LCD DRIVER */
 
-static int mp_oscsel_i2c_probe(struct i2c_client *client,
-							   const struct i2c_device_id *id)
+/* mp2019 I2C */
+static int mp2019_oscsel_i2c_probe(struct i2c_client *i2c,
+			       const struct i2c_device_id *id)
 {
 	struct device_node *clkgen_np;
 	struct i2c_client *clkgen_client;
-	struct mp_codec_priv *mp;
+	struct mp2019_codec_priv *mp;
 	int ret;
 	int i;
-	char name[80];
-	char *strategy;
-	char *rate;
 
-	dev_warn(&client->dev, "BEGIN mp_oscsel_i2c_probe");
+	dev_warn(&i2c->dev, "BEGIN mp2019_oscsel_i2c_probe");
 
-	clkgen_np = of_parse_phandle(client->dev.of_node, "mp,clkgen", 0);
-	if (!clkgen_np)
-	{
-		dev_err(&client->dev, "Failed to get clock generator phandle\n");
+	clkgen_np = of_parse_phandle(i2c->dev.of_node, "mp,clkgen", 0);
+	if (!clkgen_np) {
+		dev_err(&i2c->dev,
+			"Failed to get clock generator phandle\n");
 		return -ENODEV;
 	}
 	clkgen_client = of_find_i2c_device_by_node(clkgen_np);
 	of_node_put(clkgen_np);
-	if (!clkgen_client)
-	{
-		dev_dbg(&client->dev, "Clock generator I2C client not found\n");
+	if (!clkgen_client) {
+		dev_dbg(&i2c->dev, "Clock generator I2C client not found\n");
 		return -EPROBE_DEFER;
 	}
 	mp = i2c_get_clientdata(clkgen_client);
 	put_device(&clkgen_client->dev);
-	mp->oscsel_regmap = devm_regmap_init_i2c(client, &mp_oscsel_regmap);
-	if (IS_ERR(mp->oscsel_regmap))
-	{
+	mp->oscsel_regmap = devm_regmap_init_i2c(i2c, &mp2019_oscsel_regmap_config);
+	if (IS_ERR(mp->oscsel_regmap)) {
 		ret = PTR_ERR(mp->oscsel_regmap);
-		dev_err(&client->dev,
-				"Failed to allocate oscillator selector regmap: %d\n", ret);
+		dev_err(&i2c->dev,
+			"Failed to allocate oscillator selector regmap: %d\n",
+			ret);
 		return ret;
 	}
-	dev_warn(&client->dev, "    BEGIN i2c_set_clientdata(client, mp);");
-	i2c_set_clientdata(client, mp);
-	dev_warn(&client->dev, "    BEGIN i2c_set_clientdata(client, mp);");
-
-	dev_warn(&client->dev, "BEGIN snd_soc_register_codec");
+	dev_warn(&i2c->dev, "    BEGIN i2c_set_clientdata(client, mp);");
+	i2c_set_clientdata(i2c, mp);
+	dev_warn(&i2c->dev, "    BEGIN i2c_set_clientdata(client, mp);");
 
+	dev_warn(&i2c->dev, "BEGIN snd_soc_register_codec");
 
 	/*
 	if(maxrate == 768) {
@@ -528,173 +437,178 @@ static int mp_oscsel_i2c_probe(struct i2c_client *client,
 	}
 
 	dev_warn(&client->dev, "    STRATEGY: %s", strategy);
-	snprintf(mp_dai.name, sizeof(mp_dai.name), "%s %d %s", mp_dai.name, maxrate, strategy);
-	dev_warn(&client->dev, "*** and the name is: %s", mp_dai.name);
+	snprintf(mp2019_dai.name, sizeof(mp2019_dai.name), "%s %d %s", mp2019_dai.name, maxrate, strategy);
+	dev_warn(&client->dev, "*** and the name is: %s", mp2019_dai.name);
 
+
+	ret = snd_soc_register_codec(&clkgen_client->dev, &mp2019_codec_driver,
+	 			     &mp2019_dai, 1);
 	*/
 
-	ret = snd_soc_register_codec(&clkgen_client->dev, &mp_codec_driver, &mp_dai, 1);
+	ret = devm_snd_soc_register_component(&i2c->dev,
+			&soc_component_dev_mp2019, &mp2019_dai, 1);
+	
 
-	dev_warn(&client->dev, "END snd_soc_register_codec");
+		dev_warn(&i2c->dev, "END snd_soc_register_codec");
 	if (ret)
 		return ret;
 
-	dev_warn(&client->dev, "    BEGIN default OSCSEL regs");
+	dev_warn(&i2c->dev, "    BEGIN default OSCSEL regs");
 
-	for (i = 0; i < ARRAY_SIZE(mp_oscsel_reg_defaults); i++)
-	{
-		regmap_write(mp->oscsel_regmap, mp_oscsel_reg_defaults[i].reg,
-					 mp_oscsel_reg_defaults[i].def);
+	for (i = 0; i < ARRAY_SIZE(mp2019_oscsel_reg_defaults); i++) {
+		regmap_write(mp->oscsel_regmap, mp2019_oscsel_reg_defaults[i].reg,
+			     mp2019_oscsel_reg_defaults[i].def);
 	}
 
-	dev_warn(&client->dev, "    END default OSCSEL regs");
-	dev_warn(&client->dev, "    BEGIN default CLKGEN regs");
+	dev_warn(&i2c->dev, "    END default OSCSEL regs");
+	dev_warn(&i2c->dev, "    BEGIN default CLKGEN regs");
 
-	for (i = 0; i < ARRAY_SIZE(mp_codec_reg_defaults); i++)
-	{
-
-		clkgen_regmap_write(mp->clkgen_regmap, mp_codec_reg_defaults[i].reg,
-							mp_codec_reg_defaults[i].def);
+	for (i = 0; i < ARRAY_SIZE(mp2019_codec_reg_defaults); i++) {
+		clkgen_regmap_write(mp->clkgen_regmap,
+				    mp2019_codec_reg_defaults[i].reg,
+				    mp2019_codec_reg_defaults[i].def);
 	}
 
-	dev_warn(&client->dev, "    END default CLKGEN regs");
+	dev_warn(&i2c->dev, "    END default CLKGEN regs");
 
-	dev_warn(&client->dev, "END mp_oscsel_i2c_probe");
+	dev_warn(&i2c->dev, "END mp2019_oscsel_i2c_probe");
 
 	return 0;
 }
 
-static int mp_oscsel_i2c_remove(struct i2c_client *client)
+static int mp2019_oscsel_i2c_remove(struct i2c_client *i2c)
 {
-	snd_soc_unregister_codec(&client->dev);
-
+	snd_soc_unregister_component(&i2c->dev);
 	return 0;
 }
 
-static const struct i2c_device_id mp_oscsel_id[] = {
-	{"mp_oscsel", 0},
+static const struct i2c_device_id mp2019_oscsel_id[] = {
+	{ "mp2019_oscsel", 0 },
 	{},
 };
+MODULE_DEVICE_TABLE(i2c, mp2019_oscsel_id);
 
-MODULE_DEVICE_TABLE(i2c, mp_oscsel_id);
-
-static const struct of_device_id mp_oscsel_dt_ids[] = {
+static const struct of_device_id mp2019_oscsel_dt_ids[] = {
 	{
 		.compatible = "mp,codec-oscsel",
 	},
-	{/* sentinel */}};
-MODULE_DEVICE_TABLE(of, mp_oscsel_dt_ids);
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, mp2019_oscsel_dt_ids);
+
+static struct i2c_driver mp2019_oscsel_i2c_driver = {
+	.driver =
+		{
+			.name = "mp2019_oscsel",
+			.of_match_table = mp2019_oscsel_dt_ids,
+		},
+	.probe = mp2019_oscsel_i2c_probe,
+	.remove = mp2019_oscsel_i2c_remove,
+	.id_table = mp2019_oscsel_id,
+};
+/* end mp2019_oscel I2C */
+
+
+
+
+
 
-static struct i2c_driver mp_oscsel_i2c_driver = {
-	.driver = {
-		.name = "mp_oscsel",
-		.of_match_table = mp_oscsel_dt_ids,
+
+
+
+
+
+/* mp2019 I2C */
+static const struct of_device_id mp2019_of_match[] = {
+	{
+		.compatible = "mp,mp2019",
 	},
-	.probe = mp_oscsel_i2c_probe,
-	.remove = mp_oscsel_i2c_remove,
-	.id_table = mp_oscsel_id,
+	{}
 };
+MODULE_DEVICE_TABLE(of, mp2019_of_match);
 
-static int mp_i2c_probe(struct i2c_client *client,
-						const struct i2c_device_id *id)
+static int mp2019_i2c_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
 {
-	struct mp_codec_priv *mp;
+	struct mp2019_codec_priv *mp;
 	int ret;
 
-	dev_warn(&client->dev, "BEGIN mp_i2c_probe");
+	dev_warn(&client->dev, "BEGIN mp2019_i2c_probe");
 
 	mp = devm_kzalloc(&client->dev, sizeof(*mp), GFP_KERNEL);
 	if (!mp)
 		return -ENOMEM;
 
-	// defaults
 	mp->current_clock = 0;
 	mp->current_regmap = 0;
 
-
 	dev_warn(&client->dev, "  PRE i2c_set_clientdata");
 	i2c_set_clientdata(client, mp);
 
 	dev_warn(&client->dev, "  PRE devm_regmap_init_i2c");
-	mp->clkgen_regmap = devm_regmap_init_i2c(client, &mp_codec_regmap);
-	if (IS_ERR(mp->clkgen_regmap))
-	{
+	mp->clkgen_regmap = devm_regmap_init_i2c(client, &mp2019_clock_regmap_config);
+	if (IS_ERR(mp->clkgen_regmap)) {
 		ret = PTR_ERR(mp->clkgen_regmap);
 		dev_err(&client->dev, "Failed to allocate regmap: %d\n", ret);
 		return ret;
 	}
 
-	dev_warn(&client->dev, "END mp_i2c_probe");
+	dev_warn(&client->dev, "END mp2019_i2c_probe");
 
 	return 0;
 }
 
-static int mp_i2c_remove(struct i2c_client *client)
+static int mp2019_i2c_remove(struct i2c_client *client)
 {
 	return 0;
 }
 
-static const struct i2c_device_id mp_codec_id[] = {
-	{"mp_clkgen", 0},
+static const struct i2c_device_id mp2019_codec_id[] = {
+	{ "mp2019", 0 },
 	{},
 };
+MODULE_DEVICE_TABLE(i2c, mp2019_codec_id);
 
-MODULE_DEVICE_TABLE(i2c, mp_codec_id);
-
-static const struct of_device_id mp_codec_dt_ids[] = {
-	{
-		.compatible = "mp,codec-clkgen",
-	},
-	{/* sentinel */}};
-MODULE_DEVICE_TABLE(of, mp_codec_dt_ids);
-
-static struct i2c_driver mp_i2c_driver = {
-	.driver = {
-		.name = "mp_clkgen",
-		.of_match_table = mp_codec_dt_ids,
-	},
-	.probe = mp_i2c_probe,
-	.remove = mp_i2c_remove,
-	.id_table = mp_codec_id,
+static struct i2c_driver mp2019_i2c_driver = {
+	.driver =
+		{
+			.name = "mp2019",
+			.of_match_table = mp2019_of_match,
+		},
+	.probe = mp2019_i2c_probe,
+	.remove = mp2019_i2c_remove,
+	.id_table = mp2019_codec_id,
 };
 
-static int __init mp_codec_init(void)
+static int __init mp2019_codec_init(void)
 {
 	int ret;
 
-	ret = i2c_add_driver(&mp_i2c_driver);
-	if (ret)
-	{
+	ret = i2c_add_driver(&mp2019_i2c_driver);
+	if (ret) {
 		return ret;
 	}
-	ret = i2c_add_driver(&mp_oscsel_i2c_driver);
-	if (ret)
-	{
-		i2c_del_driver(&mp_i2c_driver);
+	ret = i2c_add_driver(&mp2019_oscsel_i2c_driver);
+	if (ret) {
+		i2c_del_driver(&mp2019_i2c_driver);
 	}
-	ret = i2c_add_driver(&mp_lcd_i2c_driver);
-	if (ret)
-	{
-		i2c_del_driver(&mp_oscsel_i2c_driver);
-		i2c_del_driver(&mp_i2c_driver);
+	ret = i2c_add_driver(&mp2019_lcd_i2c_driver);
+	if (ret) {
+		i2c_del_driver(&mp2019_oscsel_i2c_driver);
+		i2c_del_driver(&mp2019_i2c_driver);
 	}
 	return ret;
 }
+module_init(mp2019_codec_init);
 
-module_init(mp_codec_init);
-
-static void __exit mp_codec_exit(void)
+static void __exit mp2019_codec_exit(void)
 {
-	i2c_del_driver(&mp_lcd_i2c_driver);
-	i2c_del_driver(&mp_oscsel_i2c_driver);
-	i2c_del_driver(&mp_i2c_driver);
+	i2c_del_driver(&mp2019_lcd_i2c_driver);
+	i2c_del_driver(&mp2019_oscsel_i2c_driver);
+	i2c_del_driver(&mp2019_i2c_driver);
 }
+module_exit(mp2019_codec_exit);
 
-module_exit(mp_codec_exit);
-
-
-
-MODULE_DESCRIPTION("Musica Pristina ALSA SoC codec driver");
-MODULE_AUTHOR("Francesco Lavra <francescolavra.fl@gmail.com>");
+MODULE_DESCRIPTION("ASoC MP2019 Musica Pristina driver");
 MODULE_AUTHOR("Kevin Welsh <kwelsh@welshtechnologies.com>");
-MODULE_LICENSE("GPL");
+MODULE_LICENSE("GPL");
\ No newline at end of file
diff --git a/sound/soc/codecs/mp.h b/sound/soc/codecs/mp.h
index 355a3cec8c35..269184e2fc45 100644
--- a/sound/soc/codecs/mp.h
+++ b/sound/soc/codecs/mp.h
@@ -1,24 +1,43 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /*
- * mp.h - Musica Pristina ALSA SoC codec driver header file
+ * definitions for MP2019
  *
- * Copyright 2018 Welsh Technologies.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
+ * Copyright 2019 Welsh Technologies
  */
 
+#ifndef __MP2019_H__
+#define __MP2019_H__
+
+#define MP2019_FORMATS (SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
+/*
+	remove 16 to force 24 / 32 bit conversion ** SNDRV_PCM_FMTBIT_S16_LE | \
+*/
+
+
+#define MP2019_RATES (SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 |   \
+						SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 |   \
+						SNDRV_PCM_RATE_176400 | SNDRV_PCM_RATE_192000 | \
+						SNDRV_PCM_RATE_352000 | SNDRV_PCM_RATE_384000 | \
+						SNDRV_PCM_RATE_705600 | SNDRV_PCM_RATE_768000)
+
+extern const struct regmap_config mp2019_regmap_config;
+
+int mp2019_common_init(struct device *dev, struct regmap *regmap);
+
+#endif
+
 #include <linux/module.h>
 #include <linux/regmap.h>
 #include <linux/i2c.h>
 #include <sound/soc.h>
 #include "mp_clkgen.h"
 
-
-static inline int update_playback_OCXO(struct snd_soc_codec *codec, int frame_rate,
+static inline int update_playback_OCXO(struct snd_soc_dai *dai, int frame_rate,
 									   int frame_width)
 {
-	struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
+	struct snd_soc_component *component = dai->component;
+	struct mp2019_codec_priv *mp = snd_soc_component_get_drvdata(component);
+
 	pr_warn("update_playback_OCXO %d %d", frame_rate, frame_width);
 	regmap_write(mp->lcd_regmap, 0x01, frame_rate);
 	regmap_write(mp->lcd_regmap, 0x02, frame_width);
@@ -29,16 +48,16 @@ static inline int update_playback_OCXO(struct snd_soc_codec *codec, int frame_ra
 		switch (frame_width)
 		{
 		case 16:
-			clkgen_regmap_03(codec);
+			clkgen_regmap_03(mp);
 			break;
 		case 24:
-			clkgen_regmap_02(codec);
+			clkgen_regmap_02(mp);
 			break;
 		case 32:
-			clkgen_regmap_01(codec);
+			clkgen_regmap_01(mp);
 			break;
 		default:
-			dev_err(codec->dev, "%-d-bit frame width not supported\n", frame_width);
+			dev_err(component->dev, "%-d-bit frame width not supported\n", frame_width);
 			return -EINVAL;
 		}
 		break;
@@ -46,16 +65,16 @@ static inline int update_playback_OCXO(struct snd_soc_codec *codec, int frame_ra
 		switch (frame_width)
 		{
 		case 16:
-			clkgen_regmap_06(codec);
+			clkgen_regmap_06(mp);
 			break;
 		case 24:
-			clkgen_regmap_05(codec);
+			clkgen_regmap_05(mp);
 			break;
 		case 32:
-			clkgen_regmap_04(codec);
+			clkgen_regmap_04(mp);
 			break;
 		default:
-			dev_err(codec->dev, "%-d-bit frame width not supported\n", frame_width);
+			dev_err(component->dev, "%-d-bit frame width not supported\n", frame_width);
 			return -EINVAL;
 		}
 		break;
@@ -63,16 +82,16 @@ static inline int update_playback_OCXO(struct snd_soc_codec *codec, int frame_ra
 		switch (frame_width)
 		{
 		case 16:
-			clkgen_regmap_09(codec);
+			clkgen_regmap_09(mp);
 			break;
 		case 24:
-			clkgen_regmap_08(codec);
+			clkgen_regmap_08(mp);
 			break;
 		case 32:
-			clkgen_regmap_07(codec);
+			clkgen_regmap_07(mp);
 			break;
 		default:
-			dev_err(codec->dev, "%-d-bit frame width not supported\n", frame_width);
+			dev_err(component->dev, "%-d-bit frame width not supported\n", frame_width);
 			return -EINVAL;
 		}
 		break;
@@ -80,16 +99,16 @@ static inline int update_playback_OCXO(struct snd_soc_codec *codec, int frame_ra
 		switch (frame_width)
 		{
 		case 16:
-			clkgen_regmap_12(codec);
+			clkgen_regmap_12(mp);
 			break;
 		case 24:
-			clkgen_regmap_11(codec);
+			clkgen_regmap_11(mp);
 			break;
 		case 32:
-			clkgen_regmap_10(codec);
+			clkgen_regmap_10(mp);
 			break;
 		default:
-			dev_err(codec->dev, "%-d-bit frame width not supported\n", frame_width);
+			dev_err(component->dev, "%-d-bit frame width not supported\n", frame_width);
 			return -EINVAL;
 		}
 		break;
@@ -97,16 +116,16 @@ static inline int update_playback_OCXO(struct snd_soc_codec *codec, int frame_ra
 		switch (frame_width)
 		{
 		case 16:
-			clkgen_regmap_15(codec);
+			clkgen_regmap_15(mp);
 			break;
 		case 24:
-			clkgen_regmap_14(codec);
+			clkgen_regmap_14(mp);
 			break;
 		case 32:
-			clkgen_regmap_13(codec);
+			clkgen_regmap_13(mp);
 			break;
 		default:
-			dev_err(codec->dev, "%-d-bit frame width not supported\n", frame_width);
+			dev_err(component->dev, "%-d-bit frame width not supported\n", frame_width);
 			return -EINVAL;
 		}
 		break;
@@ -114,16 +133,16 @@ static inline int update_playback_OCXO(struct snd_soc_codec *codec, int frame_ra
 		switch (frame_width)
 		{
 		case 16:
-			clkgen_regmap_18(codec);
+			clkgen_regmap_18(mp);
 			break;
 		case 24:
-			clkgen_regmap_17(codec);
+			clkgen_regmap_17(mp);
 			break;
 		case 32:
-			clkgen_regmap_16(codec);
+			clkgen_regmap_16(mp);
 			break;
 		default:
-			dev_err(codec->dev, "%-d-bit frame width not supported\n", frame_width);
+			dev_err(component->dev, "%-d-bit frame width not supported\n", frame_width);
 			return -EINVAL;
 		}
 		break;
@@ -131,16 +150,16 @@ static inline int update_playback_OCXO(struct snd_soc_codec *codec, int frame_ra
 		switch (frame_width)
 		{
 		case 16:
-			clkgen_regmap_21(codec);
+			clkgen_regmap_21(mp);
 			break;
 		case 24:
-			clkgen_regmap_20(codec);
+			clkgen_regmap_20(mp);
 			break;
 		case 32:
-			clkgen_regmap_19(codec);
+			clkgen_regmap_19(mp);
 			break;
 		default:
-			dev_err(codec->dev, "%-d-bit frame width not supported\n", frame_width);
+			dev_err(component->dev, "%-d-bit frame width not supported\n", frame_width);
 			return -EINVAL;
 		}
 		break;
@@ -148,16 +167,16 @@ static inline int update_playback_OCXO(struct snd_soc_codec *codec, int frame_ra
 		switch (frame_width)
 		{
 		case 16:
-			clkgen_regmap_24(codec);
+			clkgen_regmap_24(mp);
 			break;
 		case 24:
-			clkgen_regmap_23(codec);
+			clkgen_regmap_23(mp);
 			break;
 		case 32:
-			clkgen_regmap_22(codec);
+			clkgen_regmap_22(mp);
 			break;
 		default:
-			dev_err(codec->dev, "%-d-bit frame width not supported\n", frame_width);
+			dev_err(component->dev, "%-d-bit frame width not supported\n", frame_width);
 			return -EINVAL;
 		}
 		break;
@@ -165,16 +184,16 @@ static inline int update_playback_OCXO(struct snd_soc_codec *codec, int frame_ra
 		switch (frame_width)
 		{
 		case 16:
-			clkgen_regmap_27(codec);
+			clkgen_regmap_27(mp);
 			break;
 		case 24:
-			clkgen_regmap_26(codec);
+			clkgen_regmap_26(mp);
 			break;
 		case 32:
-			clkgen_regmap_25(codec);
+			clkgen_regmap_25(mp);
 			break;
 		default:
-			dev_err(codec->dev, "%-d-bit frame width not supported\n", frame_width);
+			dev_err(component->dev, "%-d-bit frame width not supported\n", frame_width);
 			return -EINVAL;
 		}
 		break;
@@ -182,46 +201,48 @@ static inline int update_playback_OCXO(struct snd_soc_codec *codec, int frame_ra
 		switch (frame_width)
 		{
 		case 16:
-			clkgen_regmap_30(codec);
+			clkgen_regmap_30(mp);
 			break;
 		case 24:
-			clkgen_regmap_29(codec);
+			clkgen_regmap_29(mp);
 			break;
 		case 32:
-			clkgen_regmap_28(codec);
+			clkgen_regmap_28(mp);
 			break;
 		default:
-			dev_err(codec->dev, "%-d-bit frame width not supported\n", frame_width);
+			dev_err(component->dev, "%-d-bit frame width not supported\n", frame_width);
 			return -EINVAL;
 		}
 		break;
 	default:
-		dev_err(codec->dev, "frame rate %d not supported\n",
+		dev_err(component->dev, "frame rate %d not supported\n",
 				frame_rate);
 		return -EINVAL;
 	}
 	return 0;
 }
 
-static inline int update_playback_DFXO(struct snd_soc_codec *codec, int frame_rate,
+static inline int update_playback_DFXO(struct snd_soc_dai *dai, int frame_rate,
 									   int frame_width)
 {
+	struct snd_soc_component *component = dai->component;
+	struct mp2019_codec_priv *mp = snd_soc_component_get_drvdata(component);
 	switch (frame_rate)
 	{
 	case 44100:
 		switch (frame_width)
 		{
 		case 16:
-			clkgen_regmap_33(codec);
+			clkgen_regmap_33(mp);
 			break;
 		case 24:
-			clkgen_regmap_32(codec);
+			clkgen_regmap_32(mp);
 			break;
 		case 32:
-			clkgen_regmap_31(codec);
+			clkgen_regmap_31(mp);
 			break;
 		default:
-			dev_err(codec->dev, "%-d-bit frame width not supported\n", frame_width);
+			dev_err(component->dev, "%-d-bit frame width not supported\n", frame_width);
 			return -EINVAL;
 		}
 		break;
@@ -229,16 +250,16 @@ static inline int update_playback_DFXO(struct snd_soc_codec *codec, int frame_ra
 		switch (frame_width)
 		{
 		case 16:
-			clkgen_regmap_48(codec);
+			clkgen_regmap_48(mp);
 			break;
 		case 24:
-			clkgen_regmap_47(codec);
+			clkgen_regmap_47(mp);
 			break;
 		case 32:
-			clkgen_regmap_46(codec);
+			clkgen_regmap_46(mp);
 			break;
 		default:
-			dev_err(codec->dev, "%-d-bit frame width not supported\n", frame_width);
+			dev_err(component->dev, "%-d-bit frame width not supported\n", frame_width);
 			return -EINVAL;
 		}
 		break;
@@ -246,16 +267,16 @@ static inline int update_playback_DFXO(struct snd_soc_codec *codec, int frame_ra
 		switch (frame_width)
 		{
 		case 16:
-			clkgen_regmap_36(codec);
+			clkgen_regmap_36(mp);
 			break;
 		case 24:
-			clkgen_regmap_35(codec);
+			clkgen_regmap_35(mp);
 			break;
 		case 32:
-			clkgen_regmap_34(codec);
+			clkgen_regmap_34(mp);
 			break;
 		default:
-			dev_err(codec->dev, "%-d-bit frame width not supported\n", frame_width);
+			dev_err(component->dev, "%-d-bit frame width not supported\n", frame_width);
 			return -EINVAL;
 		}
 		break;
@@ -263,16 +284,16 @@ static inline int update_playback_DFXO(struct snd_soc_codec *codec, int frame_ra
 		switch (frame_width)
 		{
 		case 16:
-			clkgen_regmap_51(codec);
+			clkgen_regmap_51(mp);
 			break;
 		case 24:
-			clkgen_regmap_50(codec);
+			clkgen_regmap_50(mp);
 			break;
 		case 32:
-			clkgen_regmap_49(codec);
+			clkgen_regmap_49(mp);
 			break;
 		default:
-			dev_err(codec->dev, "%-d-bit frame width not supported\n", frame_width);
+			dev_err(component->dev, "%-d-bit frame width not supported\n", frame_width);
 			return -EINVAL;
 		}
 		break;
@@ -280,16 +301,16 @@ static inline int update_playback_DFXO(struct snd_soc_codec *codec, int frame_ra
 		switch (frame_width)
 		{
 		case 16:
-			clkgen_regmap_39(codec);
+			clkgen_regmap_39(mp);
 			break;
 		case 24:
-			clkgen_regmap_38(codec);
+			clkgen_regmap_38(mp);
 			break;
 		case 32:
-			clkgen_regmap_37(codec);
+			clkgen_regmap_37(mp);
 			break;
 		default:
-			dev_err(codec->dev, "%-d-bit frame width not supported\n", frame_width);
+			dev_err(component->dev, "%-d-bit frame width not supported\n", frame_width);
 			return -EINVAL;
 		}
 		break;
@@ -297,16 +318,16 @@ static inline int update_playback_DFXO(struct snd_soc_codec *codec, int frame_ra
 		switch (frame_width)
 		{
 		case 16:
-			clkgen_regmap_54(codec);
+			clkgen_regmap_54(mp);
 			break;
 		case 24:
-			clkgen_regmap_53(codec);
+			clkgen_regmap_53(mp);
 			break;
 		case 32:
-			clkgen_regmap_52(codec);
+			clkgen_regmap_52(mp);
 			break;
 		default:
-			dev_err(codec->dev, "%-d-bit frame width not supported\n", frame_width);
+			dev_err(component->dev, "%-d-bit frame width not supported\n", frame_width);
 			return -EINVAL;
 		}
 		break;
@@ -314,16 +335,16 @@ static inline int update_playback_DFXO(struct snd_soc_codec *codec, int frame_ra
 		switch (frame_width)
 		{
 		case 16:
-			clkgen_regmap_42(codec);
+			clkgen_regmap_42(mp);
 			break;
 		case 24:
-			clkgen_regmap_41(codec);
+			clkgen_regmap_41(mp);
 			break;
 		case 32:
-			clkgen_regmap_40(codec);
+			clkgen_regmap_40(mp);
 			break;
 		default:
-			dev_err(codec->dev, "%-d-bit frame width not supported\n", frame_width);
+			dev_err(component->dev, "%-d-bit frame width not supported\n", frame_width);
 			return -EINVAL;
 		}
 		break;
@@ -331,16 +352,16 @@ static inline int update_playback_DFXO(struct snd_soc_codec *codec, int frame_ra
 		switch (frame_width)
 		{
 		case 16:
-			clkgen_regmap_57(codec);
+			clkgen_regmap_57(mp);
 			break;
 		case 24:
-			clkgen_regmap_56(codec);
+			clkgen_regmap_56(mp);
 			break;
 		case 32:
-			clkgen_regmap_55(codec);
+			clkgen_regmap_55(mp);
 			break;
 		default:
-			dev_err(codec->dev, "%-d-bit frame width not supported\n", frame_width);
+			dev_err(component->dev, "%-d-bit frame width not supported\n", frame_width);
 			return -EINVAL;
 		}
 		break;
@@ -348,16 +369,16 @@ static inline int update_playback_DFXO(struct snd_soc_codec *codec, int frame_ra
 		switch (frame_width)
 		{
 		case 16:
-			clkgen_regmap_45(codec);
+			clkgen_regmap_45(mp);
 			break;
 		case 24:
-			clkgen_regmap_44(codec);
+			clkgen_regmap_44(mp);
 			break;
 		case 32:
-			clkgen_regmap_43(codec);
+			clkgen_regmap_43(mp);
 			break;
 		default:
-			dev_err(codec->dev, "%-d-bit frame width not supported\n", frame_width);
+			dev_err(component->dev, "%-d-bit frame width not supported\n", frame_width);
 			return -EINVAL;
 		}
 		break;
@@ -365,21 +386,21 @@ static inline int update_playback_DFXO(struct snd_soc_codec *codec, int frame_ra
 		switch (frame_width)
 		{
 		case 16:
-			clkgen_regmap_60(codec);
+			clkgen_regmap_60(mp);
 			break;
 		case 24:
-			clkgen_regmap_59(codec);
+			clkgen_regmap_59(mp);
 			break;
 		case 32:
-			clkgen_regmap_58(codec);
+			clkgen_regmap_58(mp);
 			break;
 		default:
-			dev_err(codec->dev, "%-d-bit frame width not supported\n", frame_width);
+			dev_err(component->dev, "%-d-bit frame width not supported\n", frame_width);
 			return -EINVAL;
 		}
 		break;
 	default:
-		dev_err(codec->dev, "frame rate %d not supported\n",
+		dev_err(component->dev, "frame rate %d not supported\n",
 				frame_rate);
 		return -EINVAL;
 	}
diff --git a/sound/soc/codecs/mp_clkgen.h b/sound/soc/codecs/mp_clkgen.h
index 474efdf650ec..619f24a6788b 100644
--- a/sound/soc/codecs/mp_clkgen.h
+++ b/sound/soc/codecs/mp_clkgen.h
@@ -12,38 +12,38 @@
 #include <linux/regmap.h>
 #include <sound/soc.h>
 
-/* MP codec private structure */
-struct mp_codec_priv {
-	int fmt;	/* i2s data format */
+struct mp2019_codec_priv {
+	int fmt;
 	int current_clock;
-    int current_regmap;
+	int current_regmap;
 	struct regmap *clkgen_regmap;
 	struct regmap *oscsel_regmap;
-    struct regmap *lcd_regmap;
+	struct regmap *lcd_regmap;
 };
 
 
-static inline void enable_DFXO_451584(struct snd_soc_codec *codec)
+
+static inline void enable_DFXO_451584(struct mp2019_codec_priv *mp)
 {
-	struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
+	
 	if(mp->current_clock != 3) {
 		mp->current_clock = 3;
 		regmap_write(mp->oscsel_regmap, 0x01, 0xf9);
 	}
 }
 
-static inline void enable_DFXO_49152(struct snd_soc_codec *codec)
+static inline void enable_DFXO_49152(struct mp2019_codec_priv *mp)
 {
-	struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
+	
 	if(mp->current_clock != 2) {
 		mp->current_clock = 2;
 		regmap_write(mp->oscsel_regmap, 0x01, 0xfa);
 	}
 }
 
-static inline void enable_OCXO(struct snd_soc_codec *codec)
+static inline void enable_OCXO(struct mp2019_codec_priv *mp)
 {
-	struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
+	
     int clock;
     clock = mp->current_clock;
     pr_warn("BEGIN enable_OCXO");
@@ -83,13 +83,13 @@ static inline void clkgen_regmap_write(struct regmap *regmap, unsigned int reg,
 }
 
 /* default value of I2C registers for OSCSEL */
-static const struct reg_default mp_oscsel_reg_defaults[] = {
+static const struct reg_default mp2019_oscsel_reg_defaults[] = {
 		{ 0x03,		0xf0 },
         { 0x01,		0xfc },
 };
 
 /* default value of I2C registers for CLKGEN */
-static const struct reg_default mp_codec_reg_defaults[] = {
+static const struct reg_default mp2019_codec_reg_defaults[] = {
         {0x0B24,0xC0},
         {0x0B25,0x00},
 		{0x0502,0x01},
@@ -139,14 +139,16 @@ static const struct reg_default mp_codec_reg_defaults[] = {
 		{0x011A,0x08},
 		{0x0126,0x02},
 		{0x0127,0x09},
-		// {0x0128,0x6B},
-        // LVDS
+		/* {0x0128,0x6B},
+        LVDS
+        */
         {0x0128,0x33},
-        // ----
-        // {0x0129,0x08},
-        // LVDS
+        /* ----
+         {0x0129,0x08},
+         LVDS
+        */
 		{0x0129,0x08},
-        // ----
+        /* ---- */
 		{0x012B,0x02},
 		{0x012C,0xCC},
 		{0x012D,0x00},
@@ -422,7 +424,7 @@ static const struct reg_default mp_codec_reg_defaults[] = {
 		{0x001C,0x01},
 		{0x0B24,0xC3},
 		{0x0B25,0x02},
-        //
+        /* */
         {0x0B24, 0xC0},
         {0x0B25, 0x00},
         {0x0502, 0x01},
@@ -470,10 +472,10 @@ static const struct reg_default mp_codec_reg_defaults[] = {
         {0x0B25, 0x02},
 };
 
-static inline void clkgen_regmap_01(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_01(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_OCXO(codec);
+    
+    enable_OCXO(mp);
 
     if(mp->current_regmap != 1)
     {
@@ -527,10 +529,10 @@ static inline void clkgen_regmap_01(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_02(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_02(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_OCXO(codec);
+    
+    enable_OCXO(mp);
 
     if(mp->current_regmap != 2)
     {
@@ -584,12 +586,12 @@ static inline void clkgen_regmap_02(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_03(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_03(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
+    
     pr_warn("   ***  clkgen_regmap_03");
 
-    enable_OCXO(codec);
+    enable_OCXO(mp);
 
     if(mp->current_regmap != 3)
     {
@@ -643,13 +645,13 @@ static inline void clkgen_regmap_03(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_04(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_04(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
+    
     pr_warn("   ***  clkgen_regmap_04");
 
-    enable_OCXO(codec);
-    pr_warn("   POST enable_OCXO(codec);");
+    enable_OCXO(mp);
+    pr_warn("   POST enable_OCXO(mp);");
     if(mp->current_regmap != 4)
     {
         mp->current_regmap = 4;
@@ -702,10 +704,10 @@ static inline void clkgen_regmap_04(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_05(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_05(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_OCXO(codec);
+    
+    enable_OCXO(mp);
 
     if(mp->current_regmap != 5)
     {
@@ -759,12 +761,12 @@ static inline void clkgen_regmap_05(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_06(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_06(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
+    
     pr_warn("   ***  clkgen_regmap_06");
 
-    enable_OCXO(codec);
+    enable_OCXO(mp);
 
     if(mp->current_regmap != 6)
     {
@@ -818,10 +820,10 @@ static inline void clkgen_regmap_06(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_07(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_07(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_OCXO(codec);
+    
+    enable_OCXO(mp);
 
     if(mp->current_regmap != 7)
     {
@@ -875,10 +877,10 @@ static inline void clkgen_regmap_07(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_08(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_08(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_OCXO(codec);
+    
+    enable_OCXO(mp);
 
     if(mp->current_regmap != 8)
     {
@@ -932,10 +934,10 @@ static inline void clkgen_regmap_08(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_09(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_09(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_OCXO(codec);
+    
+    enable_OCXO(mp);
 
     if(mp->current_regmap != 9)
     {
@@ -989,10 +991,10 @@ static inline void clkgen_regmap_09(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_10(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_10(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_OCXO(codec);
+    
+    enable_OCXO(mp);
 
     if(mp->current_regmap != 10)
     {
@@ -1046,10 +1048,10 @@ static inline void clkgen_regmap_10(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_11(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_11(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_OCXO(codec);
+    
+    enable_OCXO(mp);
 
     if(mp->current_regmap != 11)
     {
@@ -1102,10 +1104,10 @@ static inline void clkgen_regmap_11(struct snd_soc_codec *codec)
     }
 }
 
-static inline void clkgen_regmap_12(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_12(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_OCXO(codec);
+    
+    enable_OCXO(mp);
 
     if(mp->current_regmap != 12)
     {
@@ -1159,10 +1161,10 @@ static inline void clkgen_regmap_12(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_13(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_13(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_OCXO(codec);
+    
+    enable_OCXO(mp);
 
     if(mp->current_regmap != 13)
     {
@@ -1216,10 +1218,10 @@ static inline void clkgen_regmap_13(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_14(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_14(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_OCXO(codec);
+    
+    enable_OCXO(mp);
 
     if(mp->current_regmap != 14)
     {
@@ -1273,10 +1275,10 @@ static inline void clkgen_regmap_14(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_15(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_15(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_OCXO(codec);
+    
+    enable_OCXO(mp);
 
     if(mp->current_regmap != 15)
     {
@@ -1330,10 +1332,10 @@ static inline void clkgen_regmap_15(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_16(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_16(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_OCXO(codec);
+    
+    enable_OCXO(mp);
 
     if(mp->current_regmap != 16)
     {
@@ -1387,10 +1389,10 @@ static inline void clkgen_regmap_16(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_17(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_17(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_OCXO(codec);
+    
+    enable_OCXO(mp);
 
     if(mp->current_regmap != 17)
     {
@@ -1444,10 +1446,10 @@ static inline void clkgen_regmap_17(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_18(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_18(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_OCXO(codec);
+    
+    enable_OCXO(mp);
 
     if(mp->current_regmap != 18)
     {
@@ -1501,10 +1503,10 @@ static inline void clkgen_regmap_18(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_19(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_19(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_OCXO(codec);
+    
+    enable_OCXO(mp);
 
     if(mp->current_regmap != 19)
     {
@@ -1558,10 +1560,10 @@ static inline void clkgen_regmap_19(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_20(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_20(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_OCXO(codec);
+    
+    enable_OCXO(mp);
 
     if(mp->current_regmap != 20)
     {
@@ -1615,10 +1617,10 @@ static inline void clkgen_regmap_20(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_21(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_21(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_OCXO(codec);
+    
+    enable_OCXO(mp);
 
     if(mp->current_regmap != 21)
     {
@@ -1672,10 +1674,10 @@ static inline void clkgen_regmap_21(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_22(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_22(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_OCXO(codec);
+    
+    enable_OCXO(mp);
 
     if(mp->current_regmap != 22)
     {
@@ -1729,10 +1731,10 @@ static inline void clkgen_regmap_22(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_23(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_23(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_OCXO(codec);
+    
+    enable_OCXO(mp);
 
     if(mp->current_regmap != 23)
     {
@@ -1786,10 +1788,10 @@ static inline void clkgen_regmap_23(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_24(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_24(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_OCXO(codec);
+    
+    enable_OCXO(mp);
 
     if(mp->current_regmap != 24)
     {
@@ -1843,10 +1845,10 @@ static inline void clkgen_regmap_24(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_25(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_25(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_OCXO(codec);
+    
+    enable_OCXO(mp);
 
     if(mp->current_regmap != 25)
     {
@@ -1900,10 +1902,10 @@ static inline void clkgen_regmap_25(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_26(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_26(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_OCXO(codec);
+    
+    enable_OCXO(mp);
 
     if(mp->current_regmap != 26)
     {
@@ -1957,10 +1959,10 @@ static inline void clkgen_regmap_26(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_27(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_27(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_OCXO(codec);
+    
+    enable_OCXO(mp);
 
     if(mp->current_regmap != 27)
     {
@@ -2014,10 +2016,10 @@ static inline void clkgen_regmap_27(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_28(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_28(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_OCXO(codec);
+    
+    enable_OCXO(mp);
 
     if(mp->current_regmap != 28)
     {
@@ -2071,10 +2073,10 @@ static inline void clkgen_regmap_28(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_29(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_29(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_OCXO(codec);
+    
+    enable_OCXO(mp);
 
     if(mp->current_regmap != 29)
     {
@@ -2128,10 +2130,10 @@ static inline void clkgen_regmap_29(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_30(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_30(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_OCXO(codec);
+    
+    enable_OCXO(mp);
 
     if(mp->current_regmap != 30)
     {
@@ -2185,10 +2187,10 @@ static inline void clkgen_regmap_30(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_31(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_31(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_DFXO_451584(codec);
+    
+    enable_DFXO_451584(mp);
 
     if(mp->current_regmap != 31)
     {
@@ -2242,10 +2244,10 @@ static inline void clkgen_regmap_31(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_32(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_32(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_DFXO_451584(codec);
+    
+    enable_DFXO_451584(mp);
 
     if(mp->current_regmap != 32)
     {
@@ -2299,10 +2301,10 @@ static inline void clkgen_regmap_32(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_33(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_33(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_DFXO_451584(codec);
+    
+    enable_DFXO_451584(mp);
 
     if(mp->current_regmap != 33)
     {
@@ -2356,10 +2358,10 @@ static inline void clkgen_regmap_33(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_34(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_34(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_DFXO_451584(codec);
+    
+    enable_DFXO_451584(mp);
 
     if(mp->current_regmap != 34)
     {
@@ -2413,10 +2415,10 @@ static inline void clkgen_regmap_34(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_35(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_35(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_DFXO_451584(codec);
+    
+    enable_DFXO_451584(mp);
 
     if(mp->current_regmap != 35)
     {
@@ -2470,10 +2472,10 @@ static inline void clkgen_regmap_35(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_36(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_36(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_DFXO_451584(codec);
+    
+    enable_DFXO_451584(mp);
 
     if(mp->current_regmap != 36)
     {
@@ -2527,10 +2529,10 @@ static inline void clkgen_regmap_36(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_37(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_37(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_DFXO_451584(codec);
+    
+    enable_DFXO_451584(mp);
 
     if(mp->current_regmap != 37)
     {
@@ -2584,10 +2586,10 @@ static inline void clkgen_regmap_37(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_38(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_38(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_DFXO_451584(codec);
+    
+    enable_DFXO_451584(mp);
 
     if(mp->current_regmap != 38)
     {
@@ -2641,10 +2643,10 @@ static inline void clkgen_regmap_38(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_39(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_39(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_DFXO_451584(codec);
+    
+    enable_DFXO_451584(mp);
 
     if(mp->current_regmap != 39)
     {
@@ -2698,10 +2700,10 @@ static inline void clkgen_regmap_39(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_40(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_40(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_DFXO_451584(codec);
+    
+    enable_DFXO_451584(mp);
 
     if(mp->current_regmap != 40)
     {
@@ -2755,10 +2757,10 @@ static inline void clkgen_regmap_40(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_41(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_41(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_DFXO_451584(codec);
+    
+    enable_DFXO_451584(mp);
 
     if(mp->current_regmap != 41)
     {
@@ -2812,10 +2814,10 @@ static inline void clkgen_regmap_41(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_42(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_42(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_DFXO_451584(codec);
+    
+    enable_DFXO_451584(mp);
 
     if(mp->current_regmap != 42)
     {
@@ -2869,10 +2871,10 @@ static inline void clkgen_regmap_42(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_43(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_43(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_DFXO_451584(codec);
+    
+    enable_DFXO_451584(mp);
 
     if(mp->current_regmap != 43)
     {
@@ -2926,10 +2928,10 @@ static inline void clkgen_regmap_43(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_44(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_44(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_DFXO_451584(codec);
+    
+    enable_DFXO_451584(mp);
 
     if(mp->current_regmap != 44)
     {
@@ -2983,10 +2985,10 @@ static inline void clkgen_regmap_44(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_45(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_45(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_DFXO_451584(codec);
+    
+    enable_DFXO_451584(mp);
 
     if(mp->current_regmap != 45)
     {
@@ -3040,10 +3042,10 @@ static inline void clkgen_regmap_45(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_46(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_46(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_DFXO_49152(codec);
+    
+    enable_DFXO_49152(mp);
 
     if(mp->current_regmap != 46)
     {
@@ -3097,10 +3099,10 @@ static inline void clkgen_regmap_46(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_47(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_47(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_DFXO_49152(codec);
+    
+    enable_DFXO_49152(mp);
 
     if(mp->current_regmap != 47)
     {
@@ -3154,10 +3156,10 @@ static inline void clkgen_regmap_47(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_48(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_48(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_DFXO_49152(codec);
+    
+    enable_DFXO_49152(mp);
 
     if(mp->current_regmap != 48)
     {
@@ -3211,10 +3213,10 @@ static inline void clkgen_regmap_48(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_49(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_49(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_DFXO_49152(codec);
+    
+    enable_DFXO_49152(mp);
 
     if(mp->current_regmap != 49)
     {
@@ -3268,10 +3270,10 @@ static inline void clkgen_regmap_49(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_50(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_50(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_DFXO_49152(codec);
+    
+    enable_DFXO_49152(mp);
 
     if(mp->current_regmap != 50)
     {
@@ -3325,10 +3327,10 @@ static inline void clkgen_regmap_50(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_51(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_51(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_DFXO_49152(codec);
+    
+    enable_DFXO_49152(mp);
 
     if(mp->current_regmap != 51)
     {
@@ -3382,10 +3384,10 @@ static inline void clkgen_regmap_51(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_52(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_52(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_DFXO_49152(codec);
+    
+    enable_DFXO_49152(mp);
 
     if(mp->current_regmap != 52)
     {
@@ -3439,10 +3441,10 @@ static inline void clkgen_regmap_52(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_53(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_53(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_DFXO_49152(codec);
+    
+    enable_DFXO_49152(mp);
 
     if(mp->current_regmap != 53)
     {
@@ -3496,10 +3498,10 @@ static inline void clkgen_regmap_53(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_54(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_54(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_DFXO_49152(codec);
+    
+    enable_DFXO_49152(mp);
 
     if(mp->current_regmap != 54)
     {
@@ -3553,10 +3555,10 @@ static inline void clkgen_regmap_54(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_55(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_55(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_DFXO_49152(codec);
+    
+    enable_DFXO_49152(mp);
 
     if(mp->current_regmap != 55)
     {
@@ -3610,10 +3612,10 @@ static inline void clkgen_regmap_55(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_56(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_56(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_DFXO_49152(codec);
+    
+    enable_DFXO_49152(mp);
 
     if(mp->current_regmap != 56)
     {
@@ -3667,10 +3669,10 @@ static inline void clkgen_regmap_56(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_57(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_57(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_DFXO_49152(codec);
+    
+    enable_DFXO_49152(mp);
 
     if(mp->current_regmap != 57)
     {
@@ -3724,10 +3726,10 @@ static inline void clkgen_regmap_57(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_58(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_58(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_DFXO_49152(codec);
+    
+    enable_DFXO_49152(mp);
 
     if(mp->current_regmap != 58)
     {
@@ -3781,10 +3783,10 @@ static inline void clkgen_regmap_58(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_59(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_59(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_DFXO_49152(codec);
+    
+    enable_DFXO_49152(mp);
 
     if(mp->current_regmap != 59)
     {
@@ -3838,10 +3840,10 @@ static inline void clkgen_regmap_59(struct snd_soc_codec *codec)
 }
 
 
-static inline void clkgen_regmap_60(struct snd_soc_codec *codec)
+static inline void clkgen_regmap_60(struct mp2019_codec_priv *mp)
 {
-    struct mp_codec_priv *mp = snd_soc_codec_get_drvdata(codec);
-    enable_DFXO_49152(codec);
+    
+    enable_DFXO_49152(mp);
 
     if(mp->current_regmap != 60)
     {
