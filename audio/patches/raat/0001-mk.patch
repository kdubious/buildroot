diff --git a/.gitignore b/.gitignore
index ba6cdf7..df478f1 100644
--- a/.gitignore
+++ b/.gitignore
@@ -10,3 +10,5 @@ Release
 *.vs
 *.opendb
 
+.vscode/
+*.patch
diff --git a/COOKBOOK b/COOKBOOK
new file mode 100644
index 0000000..77eb4ff
--- /dev/null
+++ b/COOKBOOK
@@ -0,0 +1,53 @@
+###############################
+# Cookbook_RAAT
+
+# get from Github
+
+# connect to Roon
+git remote add upstream https://github.com/RoonLabs/raat.git
+
+# Pull latest from Roon
+git pull upstream master
+
+# Compile RAAT
+# compiles to ~/Roon/raat/bin/release/linux/armv7hf/
+
+make TARGET=linux-mp CONFIG=release
+cp ~/Roon/raat/bin/release/linux/armv7hf/raat_app ~/Cambio/deploy/system/opt/roon/raat_app
+
+
+################################
+# RAAT make
+
+PLATFORM=linux
+ARCH=armv7hf
+HAVE_ALSA=1
+CC=arm-linux-gnueabihf-gcc
+LD=arm-linux-gnueabihf-gcc
+CFLAGS := -DPLATFORM_LINUX -DARCH_ARM -DHAVE_ALSA -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -fPIC -marm -march=armv7-a -mfloat-abi=hard -mfpu=neon -DARM_FPU_VFP_HARD -mthumb-interwork -mtune=cortex-a9
+
+LDFLAGS=
+OPTIMIZEFLAGS=-O2
+DEBUGFLAGS=-ggdb3
+
+
+################################
+# ALSA GCC SETUP
+tar -xjf
+
+PLATFORM=linux ARCH=armv7hf HAVE_ALSA=1 CC=arm-linux-gnueabihf-gcc LD=arm-linux-gnueabihf-gcc ./configure --host=arm-linux-gnueabihf
+make
+make install
+mkdir ~/gcc-linaro/arm-linux-gnueabihf/include/alsa
+cp include/* ~/toolchain/gcc-linaro-7.4.1-2019.02-x86_64_arm-linux-gnueabihf/arm-linux-gnueabihf/include/alsa -r
+cp ~/git/ALSA/alsa-lib-1.1.8/src/.libs/* ~/toolchain/gcc-linaro-7.4.1-2019.02-x86_64_arm-linux-gnueabihf/arm-linux-gnueabihf/lib
+
+
+
+PLATFORM=linux ARCH=armv7hf HAVE_ALSA=1 CC=arm-linux-gnueabihf-gcc LD=arm-linux-gnueabihf-gcc ./configure --host=arm-linux-gnueabihf --disable-webserver --disable-client
+
+====
+====
+====
+
+bitbake console-tdx-image
diff --git a/linux-mp-buildroot.mk b/linux-mp-buildroot.mk
new file mode 100644
index 0000000..189e141
--- /dev/null
+++ b/linux-mp-buildroot.mk
@@ -0,0 +1,6 @@
+PLATFORM=linux
+ARCH=armv7hf
+HAVE_ALSA=1
+CFLAGS:=-DPLATFORM_LINUX -DARCH_ARM -DHAVE_ALSA -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -fPIC -DARM_FPU_VFP_HARD
+OPTIMIZEFLAGS=-O2
+DEBUGFLAGS=-ggdb3
\ No newline at end of file
diff --git a/linux-mp.mk b/linux-mp.mk
new file mode 100644
index 0000000..57dc431
--- /dev/null
+++ b/linux-mp.mk
@@ -0,0 +1,11 @@
+PLATFORM=linux
+ARCH=armv7hf
+HAVE_ALSA=1
+CC=arm-linux-gnueabihf-gcc
+LD=arm-linux-gnueabihf-gcc
+CFLAGS := -DPLATFORM_LINUX -DARCH_ARM -DHAVE_ALSA -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -fPIC -marm -march=armv7-a -mfloat-abi=hard -mfpu=neon -DARM_FPU_VFP_HARD -mthumb-interwork -mtune=cortex-a9
+CFLAGS += --sysroot=/usr/arm-linux-gnueabihf -I=/include
+#CFLAGS += --sysroot=~/gcc-linaro/arm-linux-gnueabihf -I=/include
+LDFLAGS=
+OPTIMIZEFLAGS=-O2
+DEBUGFLAGS=-ggdb3
\ No newline at end of file
diff --git a/patch.patch b/patch.patch
new file mode 100644
index 0000000..742a410
--- /dev/null
+++ b/patch.patch
@@ -0,0 +1,2924 @@
+diff --git a/.gitignore b/.gitignore
+index ba6cdf7..118ef3f 100644
+--- a/.gitignore
++++ b/.gitignore
+@@ -10,3 +10,4 @@ Release
+ *.vs
+ *.opendb
+ 
++.vscode/
+\ No newline at end of file
+diff --git a/linux-mp-buildroot.mk b/linux-mp-buildroot.mk
+new file mode 100644
+index 0000000..189e141
+--- /dev/null
++++ b/linux-mp-buildroot.mk
+@@ -0,0 +1,6 @@
++PLATFORM=linux
++ARCH=armv7hf
++HAVE_ALSA=1
++CFLAGS:=-DPLATFORM_LINUX -DARCH_ARM -DHAVE_ALSA -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -fPIC -DARM_FPU_VFP_HARD
++OPTIMIZEFLAGS=-O2
++DEBUGFLAGS=-ggdb3
+\ No newline at end of file
+diff --git a/linux-mp.mk b/linux-mp.mk
+new file mode 100644
+index 0000000..57dc431
+--- /dev/null
++++ b/linux-mp.mk
+@@ -0,0 +1,11 @@
++PLATFORM=linux
++ARCH=armv7hf
++HAVE_ALSA=1
++CC=arm-linux-gnueabihf-gcc
++LD=arm-linux-gnueabihf-gcc
++CFLAGS := -DPLATFORM_LINUX -DARCH_ARM -DHAVE_ALSA -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -fPIC -marm -march=armv7-a -mfloat-abi=hard -mfpu=neon -DARM_FPU_VFP_HARD -mthumb-interwork -mtune=cortex-a9
++CFLAGS += --sysroot=/usr/arm-linux-gnueabihf -I=/include
++#CFLAGS += --sysroot=~/gcc-linaro/arm-linux-gnueabihf -I=/include
++LDFLAGS=
++OPTIMIZEFLAGS=-O2
++DEBUGFLAGS=-ggdb3
+\ No newline at end of file
+diff --git a/patch.patch b/patch.patch
+new file mode 100644
+index 0000000..4e791c2
+--- /dev/null
++++ b/patch.patch
+@@ -0,0 +1,2553 @@
++diff --git a/.gitignore b/.gitignore
++index ba6cdf7..118ef3f 100644
++--- a/.gitignore
+++++ b/.gitignore
++@@ -10,3 +10,4 @@ Release
++ *.vs
++ *.opendb
++ 
+++.vscode/
++\ No newline at end of file
++diff --git a/linux-mp-buildroot.mk b/linux-mp-buildroot.mk
++new file mode 100644
++index 0000000..189e141
++--- /dev/null
+++++ b/linux-mp-buildroot.mk
++@@ -0,0 +1,6 @@
+++PLATFORM=linux
+++ARCH=armv7hf
+++HAVE_ALSA=1
+++CFLAGS:=-DPLATFORM_LINUX -DARCH_ARM -DHAVE_ALSA -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -fPIC -DARM_FPU_VFP_HARD
+++OPTIMIZEFLAGS=-O2
+++DEBUGFLAGS=-ggdb3
++\ No newline at end of file
++diff --git a/linux-mp.mk b/linux-mp.mk
++new file mode 100644
++index 0000000..57dc431
++--- /dev/null
+++++ b/linux-mp.mk
++@@ -0,0 +1,11 @@
+++PLATFORM=linux
+++ARCH=armv7hf
+++HAVE_ALSA=1
+++CC=arm-linux-gnueabihf-gcc
+++LD=arm-linux-gnueabihf-gcc
+++CFLAGS := -DPLATFORM_LINUX -DARCH_ARM -DHAVE_ALSA -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -fPIC -marm -march=armv7-a -mfloat-abi=hard -mfpu=neon -DARM_FPU_VFP_HARD -mthumb-interwork -mtune=cortex-a9
+++CFLAGS += --sysroot=/usr/arm-linux-gnueabihf -I=/include
+++#CFLAGS += --sysroot=~/gcc-linaro/arm-linux-gnueabihf -I=/include
+++LDFLAGS=
+++OPTIMIZEFLAGS=-O2
+++DEBUGFLAGS=-ggdb3
++\ No newline at end of file
++diff --git a/patch.patch b/patch.patch
++new file mode 100644
++index 0000000..a9826e7
++--- /dev/null
+++++ b/patch.patch
++@@ -0,0 +1,2177 @@
+++diff --git a/.gitignore b/.gitignore
+++index ba6cdf7..118ef3f 100644
+++--- a/.gitignore
++++++ b/.gitignore
+++@@ -10,3 +10,4 @@ Release
+++ *.vs
+++ *.opendb
+++ 
++++.vscode/
+++\ No newline at end of file
+++diff --git a/linux-mp-buildroot.mk b/linux-mp-buildroot.mk
+++new file mode 100644
+++index 0000000..189e141
+++--- /dev/null
++++++ b/linux-mp-buildroot.mk
+++@@ -0,0 +1,6 @@
++++PLATFORM=linux
++++ARCH=armv7hf
++++HAVE_ALSA=1
++++CFLAGS:=-DPLATFORM_LINUX -DARCH_ARM -DHAVE_ALSA -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -fPIC -DARM_FPU_VFP_HARD
++++OPTIMIZEFLAGS=-O2
++++DEBUGFLAGS=-ggdb3
+++\ No newline at end of file
+++diff --git a/linux-mp.mk b/linux-mp.mk
+++new file mode 100644
+++index 0000000..57dc431
+++--- /dev/null
++++++ b/linux-mp.mk
+++@@ -0,0 +1,11 @@
++++PLATFORM=linux
++++ARCH=armv7hf
++++HAVE_ALSA=1
++++CC=arm-linux-gnueabihf-gcc
++++LD=arm-linux-gnueabihf-gcc
++++CFLAGS := -DPLATFORM_LINUX -DARCH_ARM -DHAVE_ALSA -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -fPIC -marm -march=armv7-a -mfloat-abi=hard -mfpu=neon -DARM_FPU_VFP_HARD -mthumb-interwork -mtune=cortex-a9
++++CFLAGS += --sysroot=/usr/arm-linux-gnueabihf -I=/include
++++#CFLAGS += --sysroot=~/gcc-linaro/arm-linux-gnueabihf -I=/include
++++LDFLAGS=
++++OPTIMIZEFLAGS=-O2
++++DEBUGFLAGS=-ggdb3
+++\ No newline at end of file
+++diff --git a/patch.patch b/patch.patch
+++new file mode 100644
+++index 0000000..7988296
+++--- /dev/null
++++++ b/patch.patch
+++@@ -0,0 +1,1804 @@
++++diff --git a/.gitignore b/.gitignore
++++index ba6cdf7..118ef3f 100644
++++--- a/.gitignore
+++++++ b/.gitignore
++++@@ -10,3 +10,4 @@ Release
++++ *.vs
++++ *.opendb
++++ 
+++++.vscode/
++++\ No newline at end of file
++++diff --git a/linux-mp-buildroot.mk b/linux-mp-buildroot.mk
++++new file mode 100644
++++index 0000000..189e141
++++--- /dev/null
+++++++ b/linux-mp-buildroot.mk
++++@@ -0,0 +1,6 @@
+++++PLATFORM=linux
+++++ARCH=armv7hf
+++++HAVE_ALSA=1
+++++CFLAGS:=-DPLATFORM_LINUX -DARCH_ARM -DHAVE_ALSA -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -fPIC -DARM_FPU_VFP_HARD
+++++OPTIMIZEFLAGS=-O2
+++++DEBUGFLAGS=-ggdb3
++++\ No newline at end of file
++++diff --git a/linux-mp.mk b/linux-mp.mk
++++new file mode 100644
++++index 0000000..57dc431
++++--- /dev/null
+++++++ b/linux-mp.mk
++++@@ -0,0 +1,11 @@
+++++PLATFORM=linux
+++++ARCH=armv7hf
+++++HAVE_ALSA=1
+++++CC=arm-linux-gnueabihf-gcc
+++++LD=arm-linux-gnueabihf-gcc
+++++CFLAGS := -DPLATFORM_LINUX -DARCH_ARM -DHAVE_ALSA -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -fPIC -marm -march=armv7-a -mfloat-abi=hard -mfpu=neon -DARM_FPU_VFP_HARD -mthumb-interwork -mtune=cortex-a9
+++++CFLAGS += --sysroot=/usr/arm-linux-gnueabihf -I=/include
+++++#CFLAGS += --sysroot=~/gcc-linaro/arm-linux-gnueabihf -I=/include
+++++LDFLAGS=
+++++OPTIMIZEFLAGS=-O2
+++++DEBUGFLAGS=-ggdb3
++++\ No newline at end of file
++++diff --git a/patch.patch b/patch.patch
++++new file mode 100644
++++index 0000000..f22a13c
++++--- /dev/null
+++++++ b/patch.patch
++++@@ -0,0 +1,1430 @@
+++++diff --git a/.gitignore b/.gitignore
+++++index ba6cdf7..118ef3f 100644
+++++--- a/.gitignore
++++++++ b/.gitignore
+++++@@ -10,3 +10,4 @@ Release
+++++ *.vs
+++++ *.opendb
+++++ 
++++++.vscode/
+++++\ No newline at end of file
+++++diff --git a/linux-mp-buildroot.mk b/linux-mp-buildroot.mk
+++++new file mode 100644
+++++index 0000000..189e141
+++++--- /dev/null
++++++++ b/linux-mp-buildroot.mk
+++++@@ -0,0 +1,6 @@
++++++PLATFORM=linux
++++++ARCH=armv7hf
++++++HAVE_ALSA=1
++++++CFLAGS:=-DPLATFORM_LINUX -DARCH_ARM -DHAVE_ALSA -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -fPIC -DARM_FPU_VFP_HARD
++++++OPTIMIZEFLAGS=-O2
++++++DEBUGFLAGS=-ggdb3
+++++\ No newline at end of file
+++++diff --git a/linux-mp.mk b/linux-mp.mk
+++++new file mode 100644
+++++index 0000000..57dc431
+++++--- /dev/null
++++++++ b/linux-mp.mk
+++++@@ -0,0 +1,11 @@
++++++PLATFORM=linux
++++++ARCH=armv7hf
++++++HAVE_ALSA=1
++++++CC=arm-linux-gnueabihf-gcc
++++++LD=arm-linux-gnueabihf-gcc
++++++CFLAGS := -DPLATFORM_LINUX -DARCH_ARM -DHAVE_ALSA -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -fPIC -marm -march=armv7-a -mfloat-abi=hard -mfpu=neon -DARM_FPU_VFP_HARD -mthumb-interwork -mtune=cortex-a9
++++++CFLAGS += --sysroot=/usr/arm-linux-gnueabihf -I=/include
++++++#CFLAGS += --sysroot=~/gcc-linaro/arm-linux-gnueabihf -I=/include
++++++LDFLAGS=
++++++OPTIMIZEFLAGS=-O2
++++++DEBUGFLAGS=-ggdb3
+++++\ No newline at end of file
+++++diff --git a/patch.patch b/patch.patch
+++++new file mode 100644
+++++index 0000000..df19a88
+++++--- /dev/null
++++++++ b/patch.patch
+++++@@ -0,0 +1,1059 @@
++++++diff --git a/.gitignore b/.gitignore
++++++index ba6cdf7..118ef3f 100644
++++++--- a/.gitignore
+++++++++ b/.gitignore
++++++@@ -10,3 +10,4 @@ Release
++++++ *.vs
++++++ *.opendb
++++++ 
+++++++.vscode/
++++++\ No newline at end of file
++++++diff --git a/linux-mp-buildroot.mk b/linux-mp-buildroot.mk
++++++new file mode 100644
++++++index 0000000..189e141
++++++--- /dev/null
+++++++++ b/linux-mp-buildroot.mk
++++++@@ -0,0 +1,6 @@
+++++++PLATFORM=linux
+++++++ARCH=armv7hf
+++++++HAVE_ALSA=1
+++++++CFLAGS:=-DPLATFORM_LINUX -DARCH_ARM -DHAVE_ALSA -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -fPIC -DARM_FPU_VFP_HARD
+++++++OPTIMIZEFLAGS=-O2
+++++++DEBUGFLAGS=-ggdb3
++++++\ No newline at end of file
++++++diff --git a/linux-mp.mk b/linux-mp.mk
++++++new file mode 100644
++++++index 0000000..57dc431
++++++--- /dev/null
+++++++++ b/linux-mp.mk
++++++@@ -0,0 +1,11 @@
+++++++PLATFORM=linux
+++++++ARCH=armv7hf
+++++++HAVE_ALSA=1
+++++++CC=arm-linux-gnueabihf-gcc
+++++++LD=arm-linux-gnueabihf-gcc
+++++++CFLAGS := -DPLATFORM_LINUX -DARCH_ARM -DHAVE_ALSA -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -fPIC -marm -march=armv7-a -mfloat-abi=hard -mfpu=neon -DARM_FPU_VFP_HARD -mthumb-interwork -mtune=cortex-a9
+++++++CFLAGS += --sysroot=/usr/arm-linux-gnueabihf -I=/include
+++++++#CFLAGS += --sysroot=~/gcc-linaro/arm-linux-gnueabihf -I=/include
+++++++LDFLAGS=
+++++++OPTIMIZEFLAGS=-O2
+++++++DEBUGFLAGS=-ggdb3
++++++\ No newline at end of file
++++++diff --git a/patch.patch b/patch.patch
++++++new file mode 100644
++++++index 0000000..b724f4c
++++++--- /dev/null
+++++++++ b/patch.patch
++++++@@ -0,0 +1,725 @@
+++++++diff --git a/.gitignore b/.gitignore
+++++++index ba6cdf7..118ef3f 100644
+++++++--- a/.gitignore
++++++++++ b/.gitignore
+++++++@@ -10,3 +10,4 @@ Release
+++++++ *.vs
+++++++ *.opendb
+++++++ 
++++++++.vscode/
+++++++\ No newline at end of file
+++++++diff --git a/linux-mp-buildroot.mk b/linux-mp-buildroot.mk
+++++++new file mode 100644
+++++++index 0000000..189e141
+++++++--- /dev/null
++++++++++ b/linux-mp-buildroot.mk
+++++++@@ -0,0 +1,6 @@
++++++++PLATFORM=linux
++++++++ARCH=armv7hf
++++++++HAVE_ALSA=1
++++++++CFLAGS:=-DPLATFORM_LINUX -DARCH_ARM -DHAVE_ALSA -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -fPIC -DARM_FPU_VFP_HARD
++++++++OPTIMIZEFLAGS=-O2
++++++++DEBUGFLAGS=-ggdb3
+++++++\ No newline at end of file
+++++++diff --git a/linux-mp.mk b/linux-mp.mk
+++++++new file mode 100644
+++++++index 0000000..57dc431
+++++++--- /dev/null
++++++++++ b/linux-mp.mk
+++++++@@ -0,0 +1,11 @@
++++++++PLATFORM=linux
++++++++ARCH=armv7hf
++++++++HAVE_ALSA=1
++++++++CC=arm-linux-gnueabihf-gcc
++++++++LD=arm-linux-gnueabihf-gcc
++++++++CFLAGS := -DPLATFORM_LINUX -DARCH_ARM -DHAVE_ALSA -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -fPIC -marm -march=armv7-a -mfloat-abi=hard -mfpu=neon -DARM_FPU_VFP_HARD -mthumb-interwork -mtune=cortex-a9
++++++++CFLAGS += --sysroot=/usr/arm-linux-gnueabihf -I=/include
++++++++#CFLAGS += --sysroot=~/gcc-linaro/arm-linux-gnueabihf -I=/include
++++++++LDFLAGS=
++++++++OPTIMIZEFLAGS=-O2
++++++++DEBUGFLAGS=-ggdb3
+++++++\ No newline at end of file
+++++++diff --git a/patch.patch b/patch.patch
+++++++new file mode 100644
+++++++index 0000000..cab1690
+++++++--- /dev/null
++++++++++ b/patch.patch
+++++++@@ -0,0 +1,366 @@
++++++++diff --git a/.gitignore b/.gitignore
++++++++index ba6cdf7..118ef3f 100644
++++++++--- a/.gitignore
+++++++++++ b/.gitignore
++++++++@@ -10,3 +10,4 @@ Release
++++++++ *.vs
++++++++ *.opendb
++++++++ 
+++++++++.vscode/
++++++++\ No newline at end of file
++++++++diff --git a/a.out b/a.out
++++++++new file mode 100755
++++++++index 0000000..eb82739
++++++++Binary files /dev/null and b/a.out differ
++++++++diff --git a/linux-mp-buildroot.mk b/linux-mp-buildroot.mk
++++++++new file mode 100644
++++++++index 0000000..189e141
++++++++--- /dev/null
+++++++++++ b/linux-mp-buildroot.mk
++++++++@@ -0,0 +1,6 @@
+++++++++PLATFORM=linux
+++++++++ARCH=armv7hf
+++++++++HAVE_ALSA=1
+++++++++CFLAGS:=-DPLATFORM_LINUX -DARCH_ARM -DHAVE_ALSA -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -fPIC -DARM_FPU_VFP_HARD
+++++++++OPTIMIZEFLAGS=-O2
+++++++++DEBUGFLAGS=-ggdb3
++++++++\ No newline at end of file
++++++++diff --git a/linux-mp.mk b/linux-mp.mk
++++++++new file mode 100644
++++++++index 0000000..57dc431
++++++++--- /dev/null
+++++++++++ b/linux-mp.mk
++++++++@@ -0,0 +1,11 @@
+++++++++PLATFORM=linux
+++++++++ARCH=armv7hf
+++++++++HAVE_ALSA=1
+++++++++CC=arm-linux-gnueabihf-gcc
+++++++++LD=arm-linux-gnueabihf-gcc
+++++++++CFLAGS := -DPLATFORM_LINUX -DARCH_ARM -DHAVE_ALSA -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -fPIC -marm -march=armv7-a -mfloat-abi=hard -mfpu=neon -DARM_FPU_VFP_HARD -mthumb-interwork -mtune=cortex-a9
+++++++++CFLAGS += --sysroot=/usr/arm-linux-gnueabihf -I=/include
+++++++++#CFLAGS += --sysroot=~/gcc-linaro/arm-linux-gnueabihf -I=/include
+++++++++LDFLAGS=
+++++++++OPTIMIZEFLAGS=-O2
+++++++++DEBUGFLAGS=-ggdb3
++++++++\ No newline at end of file
++++++++diff --git a/patch.patch b/patch.patch
++++++++new file mode 100644
++++++++index 0000000..1628b87
++++++++--- /dev/null
+++++++++++ b/patch.patch
++++++++@@ -0,0 +1,56 @@
+++++++++diff --git a/a.out b/a.out
+++++++++deleted file mode 100755
+++++++++index eb82739..0000000
+++++++++Binary files a/a.out and /dev/null differ
+++++++++diff --git a/linux-lime2.mk b/linux-lime2.mk
+++++++++deleted file mode 100644
+++++++++index 4a6a9c2..0000000
+++++++++--- a/linux-lime2.mk
++++++++++++ /dev/null
+++++++++@@ -1,11 +0,0 @@
+++++++++-PLATFORM=linux
+++++++++-ARCH=armv7hf
+++++++++-HAVE_ALSA=1
+++++++++-CC=arm-linux-gnueabihf-gcc
+++++++++-LD=arm-linux-gnueabihf-gcc
+++++++++-CFLAGS := -DPLATFORM_LINUX -DARCH_ARM -DHAVE_ALSA -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -fPIC -marm -march=armv7-a -mfloat-abi=hard -mfpu=neon -DARM_FPU_VFP_HARD -mthumb-interwork -mtune=cortex-a9
+++++++++-CFLAGS += --sysroot=/usr/arm-linux-gnueabihf
+++++++++-LDFLAGS=
+++++++++-OPTIMIZEFLAGS=-O2
+++++++++-DEBUGFLAGS=-ggdb3
+++++++++-
+++++++++diff --git a/linux-lime2.mk~ b/linux-lime2.mk~
+++++++++deleted file mode 100644
+++++++++index 7518919..0000000
+++++++++--- a/linux-lime2.mk~
++++++++++++ /dev/null
+++++++++@@ -1,11 +0,0 @@
+++++++++-PLATFORM=linux
+++++++++-ARCH=armv7hf
+++++++++-HAVE_ALSA=1
+++++++++-CC=arm-linux-gnueabihf-gcc
+++++++++-LD=/usr/arm-linux-gnueabihf/bin/ld
+++++++++-CFLAGS := -DPLATFORM_LINUX -DARCH_ARM -DHAVE_ALSA -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -fPIC -marm -march=armv7-a -mfloat-abi=hard -mfpu=neon -DARM_FPU_VFP_HARD -mthumb-interwork -mtune=cortex-a9
+++++++++-CFLAGS += --sysroot=/usr/arm-linux-gnueabihf
+++++++++-LDFLAGS=
+++++++++-OPTIMIZEFLAGS=-O2
+++++++++-DEBUGFLAGS=-ggdb3
+++++++++-
+++++++++diff --git a/linux-mp.mk b/linux-mp.mk
+++++++++deleted file mode 100644
+++++++++index 57dc431..0000000
+++++++++--- a/linux-mp.mk
++++++++++++ /dev/null
+++++++++@@ -1,11 +0,0 @@
+++++++++-PLATFORM=linux
+++++++++-ARCH=armv7hf
+++++++++-HAVE_ALSA=1
+++++++++-CC=arm-linux-gnueabihf-gcc
+++++++++-LD=arm-linux-gnueabihf-gcc
+++++++++-CFLAGS := -DPLATFORM_LINUX -DARCH_ARM -DHAVE_ALSA -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -fPIC -marm -march=armv7-a -mfloat-abi=hard -mfpu=neon -DARM_FPU_VFP_HARD -mthumb-interwork -mtune=cortex-a9
+++++++++-CFLAGS += --sysroot=/usr/arm-linux-gnueabihf -I=/include
+++++++++-#CFLAGS += --sysroot=~/gcc-linaro/arm-linux-gnueabihf -I=/include
+++++++++-LDFLAGS=
+++++++++-OPTIMIZEFLAGS=-O2
+++++++++-DEBUGFLAGS=-ggdb3
+++++++++\ No newline at end of file
++++++++diff --git a/plugins/build.mk b/plugins/build.mk
++++++++index b22ce82..499a18a 100644
++++++++--- a/plugins/build.mk
+++++++++++ b/plugins/build.mk
++++++++@@ -32,6 +32,14 @@ raat_source_selection_test_SOURCES  := raat_plugin_source_selection_test.c
++++++++ 
++++++++ $(eval $(call BUILD_STATICLIB,raat_source_selection_test))
++++++++ 
+++++++++#
+++++++++# source_selection_mp plugin
+++++++++#
+++++++++raat_source_selection_mp_DEPS     := raat
+++++++++raat_source_selection_mp_SOURCES  := raat_plugin_source_selection_mp.c
+++++++++
+++++++++$(eval $(call BUILD_STATICLIB,raat_source_selection_mp))
+++++++++
++++++++ #
++++++++ # volume_dummy plugin
++++++++ #
++++++++diff --git a/plugins/raat_plugin_source_selection_mp.c b/plugins/raat_plugin_source_selection_mp.c
++++++++new file mode 100644
++++++++index 0000000..2e667fc
++++++++--- /dev/null
+++++++++++ b/plugins/raat_plugin_source_selection_mp.c
++++++++@@ -0,0 +1,143 @@
+++++++++//
+++++++++// The contents of this file are subject to RAAT SDK License
+++++++++// agreement; You may not use this file except in compliance
+++++++++// with the License.
+++++++++//
+++++++++// Copyright (C) 2015 Roon Labs LLC
+++++++++//
+++++++++// All Rights Reserved.
+++++++++//
+++++++++#include "raat_plugin_source_selection_mp.h"
+++++++++#include "rc_list.h"
+++++++++
+++++++++#include <uv.h>
+++++++++
+++++++++#include <stdio.h>
+++++++++#include <stdlib.h>
+++++++++
+++++++++#define RAAT__CURRENT_LOG self->log
+++++++++
+++++++++/*
+++++++++ * SourceSelection Plugin
+++++++++ */
+++++++++typedef struct {
+++++++++    RAAT__SourceSelectionPlugin          plugin;          // must be first item in struct
+++++++++    uv_mutex_t                           lock;
+++++++++    RC__Allocator                       *alloc;
+++++++++    RAAT__SourceSelectionStateListeners  state_listeners;
+++++++++    RAAT__Log                           *log;
+++++++++    RAAT__SourceSelectionStatus          status;
+++++++++    RAAT__OutputPlugin                  *output;
+++++++++    json_t                              *info;
+++++++++} MPSourceSelectionPlugin;
+++++++++
+++++++++static RC__Status source_selection_add_state_listener(void *vself, RAAT__SourceSelectionStateCallback cb, void *userdata) {
+++++++++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
+++++++++    return RAAT__source_selection_state_listeners_add(&self->state_listeners, cb, userdata);
+++++++++}
+++++++++
+++++++++static RC__Status source_selection_remove_state_listener(void *vself, RAAT__SourceSelectionStateCallback cb, void *userdata) {
+++++++++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
+++++++++    return RAAT__source_selection_state_listeners_remove(&self->state_listeners, cb, userdata);
+++++++++}
+++++++++
+++++++++static RC__Status source_selection_get_info(void *vself, json_t **out_info) {
+++++++++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
+++++++++
+++++++++    RC__ASSERT(self);
+++++++++    RC__ASSERT(out_info);
+++++++++
+++++++++    json_incref(self->info);
+++++++++    *out_info = self->info;
+++++++++
+++++++++    return RC__STATUS_SUCCESS;
+++++++++}
+++++++++
+++++++++static RC__Status source_selection_get_state(void *vself, RAAT__SourceSelectionState *out_state) {
+++++++++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
+++++++++
+++++++++    RC__ASSERT(self != NULL);
+++++++++    RC__ASSERT(out_state != NULL);
+++++++++
+++++++++    out_state->status   = self->status;
+++++++++
+++++++++    return RC__STATUS_SUCCESS;
+++++++++}
+++++++++
+++++++++static void source_selection_request_source(void *vself, RAAT__SourceSelectionRequestSourceCallback cb, void *cb_userdata) {
+++++++++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
+++++++++
+++++++++    RAAT__TRACE("[source_selection/mp] requesting source");
+++++++++    RC__ASSERT(self);
+++++++++    RAAT__TRACE("[source_selection/mp] source acquired");
+++++++++
+++++++++    json_t *config = json_object_get(self->info, "config");
+++++++++    const char *source_selection_command = json_string_value(json_object_get(config, "source_selection_command"));
+++++++++    RAAT__TRACE("[source_selection/mp] source_selection_command: %s", source_selection_command);
+++++++++
+++++++++    RAAT__TRACE("[source_selection/mp] pre /opt/roon/sourceselect");
+++++++++    system(source_selection_command);
+++++++++    RAAT__TRACE("[source_selection/mp] post /opt/roon/sourceselect");
+++++++++
+++++++++    self->status = RAAT__SOURCE_SELECTION_STATUS_SELECTED; 
+++++++++    RAAT__SourceSelectionState state = {0,};
+++++++++    state.status = self->status;
+++++++++    RAAT__source_selection_state_listeners_invoke(&self->state_listeners, &state);
+++++++++
+++++++++    cb(cb_userdata, RC__STATUS_SUCCESS, NULL);
+++++++++}
+++++++++
+++++++++static void source_selection_request_standby(void *vself, RAAT__SourceSelectionRequestSourceCallback cb, void *cb_userdata) {
+++++++++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
+++++++++
+++++++++    RAAT__TRACE("[source_selection/mp] requesting standby");
+++++++++    RC__ASSERT(self);
+++++++++
+++++++++    RAAT__TRACE("[source_selection/mp] in standby");
+++++++++
+++++++++    self->status = RAAT__SOURCE_SELECTION_STATUS_STANDBY; 
+++++++++    RAAT__SourceSelectionState state = {0,};
+++++++++    state.status = self->status;
+++++++++    RAAT__source_selection_state_listeners_invoke(&self->state_listeners, &state);
+++++++++
+++++++++    cb(cb_userdata, RC__STATUS_SUCCESS, NULL);
+++++++++}
+++++++++
+++++++++RC__Status 
+++++++++RAAT__mp_source_selection_plugin_new(RC__Allocator *alloc, RAAT__Device *device, json_t *config, RAAT__SourceSelectionPlugin **out_source_selection) { 
+++++++++    alloc = RC__allocator_default(alloc);
+++++++++    MPSourceSelectionPlugin *self      = RC__new0(alloc, MPSourceSelectionPlugin, 1);
+++++++++    if (self == NULL) return RC__STATUS_OUT_OF_MEMORY;
+++++++++    self->alloc                        = alloc;
+++++++++    self->log                          = RAAT__device_get_log(device);
+++++++++    self->plugin.get_info              = source_selection_get_info;
+++++++++    self->plugin.add_state_listener    = source_selection_add_state_listener;
+++++++++    self->plugin.remove_state_listener = source_selection_remove_state_listener;
+++++++++    self->plugin.get_state             = source_selection_get_state;
+++++++++    self->plugin.request_source        = source_selection_request_source;
+++++++++    self->plugin.request_standby       = source_selection_request_standby;
+++++++++    self->status                       = RAAT__SOURCE_SELECTION_STATUS_STANDBY;
+++++++++    self->output                       = RAAT__device_get_output_plugin(device);
+++++++++
+++++++++    uv_mutex_init(&self->lock);
+++++++++    RAAT__source_selection_state_listeners_init(&self->state_listeners, self->alloc);
+++++++++
+++++++++    self->info = json_object();
+++++++++    json_object_set(self->info, "config", config);
+++++++++
+++++++++    RAAT__TRACE("[source_selection/test] initialized");
+++++++++
+++++++++    *out_source_selection = &self->plugin;
+++++++++    return RC__STATUS_SUCCESS;
+++++++++}
+++++++++
+++++++++void
+++++++++RAAT__mp_source_selection_plugin_delete(RAAT__SourceSelectionPlugin *source_selection) {
+++++++++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)source_selection;
+++++++++    uv_mutex_destroy(&self->lock);
+++++++++    if (self->info) json_decref(self->info);
+++++++++    RAAT__source_selection_state_listeners_destroy(&self->state_listeners);
+++++++++    RC__free(self->alloc, self);
+++++++++}
+++++++++
+++++++++
++++++++diff --git a/plugins/raat_plugin_source_selection_mp.h b/plugins/raat_plugin_source_selection_mp.h
++++++++new file mode 100644
++++++++index 0000000..850e8c6
++++++++--- /dev/null
+++++++++++ b/plugins/raat_plugin_source_selection_mp.h
++++++++@@ -0,0 +1,36 @@
+++++++++//
+++++++++// The contents of this file are subject to RAAT SDK License
+++++++++// agreement; You may not use this file except in compliance
+++++++++// with the License.
+++++++++//
+++++++++// Copyright (C) 2015 Roon Labs LLC
+++++++++//
+++++++++// All Rights Reserved.
+++++++++//
+++++++++#ifndef INCLUDED_RAAT_PLUGIN_SOURCE_SELECTION_MP_H
+++++++++#define INCLUDED_RAAT_PLUGIN_SOURCE_SELECTION_MP_H
+++++++++
+++++++++#include "rc_base.h"
+++++++++#include "rc_allocator.h"
+++++++++#include "rc_status.h"
+++++++++#include "raat_fwd.h"
+++++++++#include "raat_device.h"
+++++++++#include "raat_plugin_source_selection.h"
+++++++++#include "raat_plugin_output.h"
+++++++++
+++++++++#include <jansson.h>
+++++++++
+++++++++#ifdef __cplusplus
+++++++++extern "C" {
+++++++++#endif
+++++++++
+++++++++RC__Status
+++++++++RAAT__mp_source_selection_plugin_new(RC__Allocator *alloc, RAAT__Device *device, json_t *config, RAAT__SourceSelectionPlugin **out_source_selection); 
+++++++++void
+++++++++RAAT__mp_source_selection_plugin_delete(RAAT__SourceSelectionPlugin *out_source_selection);
+++++++++
+++++++++#ifdef __cplusplus
+++++++++}
+++++++++#endif
+++++++++
+++++++++#endif
++++++++diff --git a/plugins/raat_plugin_source_selection_test.c b/plugins/raat_plugin_source_selection_test.c
++++++++index ae54153..a51e10c 100644
++++++++--- a/plugins/raat_plugin_source_selection_test.c
+++++++++++ b/plugins/raat_plugin_source_selection_test.c
++++++++@@ -12,6 +12,9 @@
++++++++ 
++++++++ #include <uv.h>
++++++++ 
+++++++++#include <stdio.h>
+++++++++#include <stdlib.h>
+++++++++
++++++++ #define RAAT__CURRENT_LOG self->log
++++++++ 
++++++++ /*
++++++++diff --git a/raat_app/build.mk b/raat_app/build.mk
++++++++index f989bbd..6113577 100644
++++++++--- a/raat_app/build.mk
+++++++++++ b/raat_app/build.mk
++++++++@@ -8,6 +8,7 @@ raat_app_DEPS    = raat	\
++++++++ 		   raat_output_null \
++++++++ 		   raat_output_capture \
++++++++ 		   raat_source_selection_test \
+++++++++		   raat_source_selection_mp \
++++++++ 		   raat_volume_dummy \
++++++++ 		   raat_volume_incremental \
++++++++ 		   raat_volume_software \
++++++++diff --git a/raat_app/raat_app.c b/raat_app/raat_app.c
++++++++index 4763626..6f60bcf 100644
++++++++--- a/raat_app/raat_app.c
+++++++++++ b/raat_app/raat_app.c
++++++++@@ -24,6 +24,7 @@
++++++++ #include "raat_plugin_output_null.h"
++++++++ #include "raat_plugin_output_capture.h"
++++++++ #include "raat_plugin_source_selection_test.h"
+++++++++#include "raat_plugin_source_selection_mp.h"
++++++++ #include "raat_plugin_transport_test.h"
++++++++ 
++++++++ #if defined(PLATFORM_LINUX) && defined(HAVE_ALSA)
++++++++@@ -248,7 +249,9 @@ int main(int argc, char **argv) {
++++++++         if (!strcmp(type, "test")) {
++++++++             status = RAAT__test_source_selection_plugin_new(RC__ALLOCATOR_DEFAULT, device, source_selection, &source_selection_plugin);
++++++++             if (!RC__STATUS_IS_SUCCESS(status)) { rcfail(status, "failed to initialize test source_selection"); }
++++++++-
+++++++++        } else if (!strcmp(type, "mp")) {
+++++++++            status = RAAT__mp_source_selection_plugin_new(RC__ALLOCATOR_DEFAULT, device, source_selection, &source_selection_plugin);
+++++++++            if (!RC__STATUS_IS_SUCCESS(status)) { rcfail(status, "failed to initialize MP source_selection"); }
++++++++         } else {
++++++++             if (type == NULL) fail("Invalid config %s: unknown source_selection type '%s'", type);
++++++++         }
+++++++diff --git a/plugins/build.mk b/plugins/build.mk
+++++++index b22ce82..499a18a 100644
+++++++--- a/plugins/build.mk
++++++++++ b/plugins/build.mk
+++++++@@ -32,6 +32,14 @@ raat_source_selection_test_SOURCES  := raat_plugin_source_selection_test.c
+++++++ 
+++++++ $(eval $(call BUILD_STATICLIB,raat_source_selection_test))
+++++++ 
++++++++#
++++++++# source_selection_mp plugin
++++++++#
++++++++raat_source_selection_mp_DEPS     := raat
++++++++raat_source_selection_mp_SOURCES  := raat_plugin_source_selection_mp.c
++++++++
++++++++$(eval $(call BUILD_STATICLIB,raat_source_selection_mp))
++++++++
+++++++ #
+++++++ # volume_dummy plugin
+++++++ #
+++++++diff --git a/plugins/raat_plugin_source_selection_mp.c b/plugins/raat_plugin_source_selection_mp.c
+++++++new file mode 100644
+++++++index 0000000..7b1d819
+++++++--- /dev/null
++++++++++ b/plugins/raat_plugin_source_selection_mp.c
+++++++@@ -0,0 +1,170 @@
++++++++//
++++++++// The contents of this file are subject to RAAT SDK License
++++++++// agreement; You may not use this file except in compliance
++++++++// with the License.
++++++++//
++++++++// Copyright (C) 2015 Roon Labs LLC
++++++++//
++++++++// All Rights Reserved.
++++++++//
++++++++#include "raat_plugin_source_selection_mp.h"
++++++++#include "rc_list.h"
++++++++
++++++++#include <uv.h>
++++++++
++++++++#include <stdio.h>
++++++++#include <stdlib.h>
++++++++#include <signal.h>
++++++++#include <unistd.h>
++++++++
++++++++#define RAAT__CURRENT_LOG self->log
++++++++
++++++++/*
++++++++ * SourceSelection Plugin
++++++++ */
++++++++typedef struct {
++++++++    RAAT__SourceSelectionPlugin          plugin;          // must be first item in struct
++++++++    uv_mutex_t                           lock;
++++++++    RC__Allocator                       *alloc;
++++++++    RAAT__SourceSelectionStateListeners  state_listeners;
++++++++    RAAT__Log                           *log;
++++++++    RAAT__SourceSelectionStatus          status;
++++++++    RAAT__OutputPlugin                  *output;
++++++++    json_t                              *info;
++++++++} MPSourceSelectionPlugin;
++++++++
++++++++static RC__Status source_selection_add_state_listener(void *vself, RAAT__SourceSelectionStateCallback cb, void *userdata) {
++++++++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
++++++++    return RAAT__source_selection_state_listeners_add(&self->state_listeners, cb, userdata);
++++++++}
++++++++
++++++++static RC__Status source_selection_remove_state_listener(void *vself, RAAT__SourceSelectionStateCallback cb, void *userdata) {
++++++++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
++++++++    return RAAT__source_selection_state_listeners_remove(&self->state_listeners, cb, userdata);
++++++++}
++++++++
++++++++static void sig_handler(int signo) {
++++++++    /*
++++++++    call with:
++++++++    kill -USR1 {pid}
++++++++    */
++++++++    if (signo == SIGUSR1) {
++++++++        printf("received SIGUSR2\n");
++++++++        /*
++++++++        json_t *reason = json_object();
++++++++        json_object_set_new(reason, "reason", json_string("source_deselected"));
++++++++        output->force_teardown(self->output, reason);
++++++++        json_decref(reason);
++++++++        */
++++++++    } else {
++++++++        printf("OOPS: KEW\n");
++++++++    }
++++++++}
++++++++
++++++++static RC__Status source_selection_get_info(void *vself, json_t **out_info) {
++++++++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
++++++++
++++++++    RC__ASSERT(self);
++++++++    RC__ASSERT(out_info);
++++++++
++++++++    json_incref(self->info);
++++++++    *out_info = self->info;
++++++++
++++++++    return RC__STATUS_SUCCESS;
++++++++}
++++++++
++++++++static RC__Status source_selection_get_state(void *vself, RAAT__SourceSelectionState *out_state) {
++++++++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
++++++++
++++++++    RC__ASSERT(self != NULL);
++++++++    RC__ASSERT(out_state != NULL);
++++++++
++++++++    out_state->status   = self->status;
++++++++
++++++++    return RC__STATUS_SUCCESS;
++++++++}
++++++++
++++++++static void source_selection_request_source(void *vself, RAAT__SourceSelectionRequestSourceCallback cb, void *cb_userdata) {
++++++++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
++++++++
++++++++    RAAT__TRACE("[source_selection/mp] requesting source");
++++++++    RC__ASSERT(self);
++++++++    RAAT__TRACE("[source_selection/mp] source acquired");
++++++++
++++++++    json_t *config = json_object_get(self->info, "config");
++++++++    const char *source_selection_command = json_string_value(json_object_get(config, "source_selection_command"));
++++++++    RAAT__TRACE("[source_selection/mp] source_selection_command: %s", source_selection_command);
++++++++
++++++++    RAAT__TRACE("[source_selection/mp] pre /opt/roon/sourceselect");
++++++++    system(source_selection_command);
++++++++    RAAT__TRACE("[source_selection/mp] post /opt/roon/sourceselect");
++++++++
++++++++    self->status = RAAT__SOURCE_SELECTION_STATUS_SELECTED; 
++++++++    RAAT__SourceSelectionState state = {0,};
++++++++    state.status = self->status;
++++++++    RAAT__source_selection_state_listeners_invoke(&self->state_listeners, &state);
++++++++
++++++++    cb(cb_userdata, RC__STATUS_SUCCESS, NULL);
++++++++}
++++++++
++++++++static void source_selection_request_standby(void *vself, RAAT__SourceSelectionRequestSourceCallback cb, void *cb_userdata) {
++++++++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
++++++++
++++++++    RAAT__TRACE("[source_selection/mp] requesting standby");
++++++++    RC__ASSERT(self);
++++++++
++++++++    RAAT__TRACE("[source_selection/mp] in standby");
++++++++
++++++++    self->status = RAAT__SOURCE_SELECTION_STATUS_STANDBY; 
++++++++    RAAT__SourceSelectionState state = {0,};
++++++++    state.status = self->status;
++++++++    RAAT__source_selection_state_listeners_invoke(&self->state_listeners, &state);
++++++++
++++++++    cb(cb_userdata, RC__STATUS_SUCCESS, NULL);
++++++++}
++++++++
++++++++RC__Status 
++++++++RAAT__mp_source_selection_plugin_new(RC__Allocator *alloc, RAAT__Device *device, json_t *config, RAAT__SourceSelectionPlugin **out_source_selection) { 
++++++++    alloc = RC__allocator_default(alloc);
++++++++    MPSourceSelectionPlugin *self      = RC__new0(alloc, MPSourceSelectionPlugin, 1);
++++++++    if (self == NULL) return RC__STATUS_OUT_OF_MEMORY;
++++++++    self->alloc                        = alloc;
++++++++    self->log                          = RAAT__device_get_log(device);
++++++++    self->plugin.get_info              = source_selection_get_info;
++++++++    self->plugin.add_state_listener    = source_selection_add_state_listener;
++++++++    self->plugin.remove_state_listener = source_selection_remove_state_listener;
++++++++    self->plugin.get_state             = source_selection_get_state;
++++++++    self->plugin.request_source        = source_selection_request_source;
++++++++    self->plugin.request_standby       = source_selection_request_standby;
++++++++    self->status                       = RAAT__SOURCE_SELECTION_STATUS_STANDBY;
++++++++    self->output                       = RAAT__device_get_output_plugin(device);
++++++++
++++++++    uv_mutex_init(&self->lock);
++++++++    RAAT__source_selection_state_listeners_init(&self->state_listeners, self->alloc);
++++++++
++++++++    self->info = json_object();
++++++++    json_object_set(self->info, "config", config);
++++++++
++++++++    RAAT__TRACE("[source_selection/mp] initialized");
++++++++
++++++++            if(signal(SIGUSR2, sig_handler) == SIG_ERR) {
++++++++                RAAT__TRACE("[source_selection/mp] ERROR signal(SIGUSR2, sig_handler) == SIG_ERR");
++++++++            } else {
++++++++                RAAT__TRACE("[source_selection/mp] signal(SIGUSR2, sig_handler) == SIG_ERR");
++++++++            }
++++++++
++++++++
++++++++    *out_source_selection = &self->plugin;
++++++++    return RC__STATUS_SUCCESS;
++++++++}
++++++++
++++++++void
++++++++RAAT__mp_source_selection_plugin_delete(RAAT__SourceSelectionPlugin *source_selection) {
++++++++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)source_selection;
++++++++    uv_mutex_destroy(&self->lock);
++++++++    if (self->info) json_decref(self->info);
++++++++    RAAT__source_selection_state_listeners_destroy(&self->state_listeners);
++++++++    RC__free(self->alloc, self);
++++++++}
++++++++
++++++++
+++++++diff --git a/plugins/raat_plugin_source_selection_mp.h b/plugins/raat_plugin_source_selection_mp.h
+++++++new file mode 100644
+++++++index 0000000..850e8c6
+++++++--- /dev/null
++++++++++ b/plugins/raat_plugin_source_selection_mp.h
+++++++@@ -0,0 +1,36 @@
++++++++//
++++++++// The contents of this file are subject to RAAT SDK License
++++++++// agreement; You may not use this file except in compliance
++++++++// with the License.
++++++++//
++++++++// Copyright (C) 2015 Roon Labs LLC
++++++++//
++++++++// All Rights Reserved.
++++++++//
++++++++#ifndef INCLUDED_RAAT_PLUGIN_SOURCE_SELECTION_MP_H
++++++++#define INCLUDED_RAAT_PLUGIN_SOURCE_SELECTION_MP_H
++++++++
++++++++#include "rc_base.h"
++++++++#include "rc_allocator.h"
++++++++#include "rc_status.h"
++++++++#include "raat_fwd.h"
++++++++#include "raat_device.h"
++++++++#include "raat_plugin_source_selection.h"
++++++++#include "raat_plugin_output.h"
++++++++
++++++++#include <jansson.h>
++++++++
++++++++#ifdef __cplusplus
++++++++extern "C" {
++++++++#endif
++++++++
++++++++RC__Status
++++++++RAAT__mp_source_selection_plugin_new(RC__Allocator *alloc, RAAT__Device *device, json_t *config, RAAT__SourceSelectionPlugin **out_source_selection); 
++++++++void
++++++++RAAT__mp_source_selection_plugin_delete(RAAT__SourceSelectionPlugin *out_source_selection);
++++++++
++++++++#ifdef __cplusplus
++++++++}
++++++++#endif
++++++++
++++++++#endif
+++++++diff --git a/plugins/raat_plugin_source_selection_test.c b/plugins/raat_plugin_source_selection_test.c
+++++++index ae54153..a51e10c 100644
+++++++--- a/plugins/raat_plugin_source_selection_test.c
++++++++++ b/plugins/raat_plugin_source_selection_test.c
+++++++@@ -12,6 +12,9 @@
+++++++ 
+++++++ #include <uv.h>
+++++++ 
++++++++#include <stdio.h>
++++++++#include <stdlib.h>
++++++++
+++++++ #define RAAT__CURRENT_LOG self->log
+++++++ 
+++++++ /*
+++++++diff --git a/raat_app/build.mk b/raat_app/build.mk
+++++++index f989bbd..6113577 100644
+++++++--- a/raat_app/build.mk
++++++++++ b/raat_app/build.mk
+++++++@@ -8,6 +8,7 @@ raat_app_DEPS    = raat	\
+++++++ 		   raat_output_null \
+++++++ 		   raat_output_capture \
+++++++ 		   raat_source_selection_test \
++++++++		   raat_source_selection_mp \
+++++++ 		   raat_volume_dummy \
+++++++ 		   raat_volume_incremental \
+++++++ 		   raat_volume_software \
+++++++diff --git a/raat_app/raat_app.c b/raat_app/raat_app.c
+++++++index 4763626..b04cbce 100644
+++++++--- a/raat_app/raat_app.c
++++++++++ b/raat_app/raat_app.c
+++++++@@ -24,6 +24,7 @@
+++++++ #include "raat_plugin_output_null.h"
+++++++ #include "raat_plugin_output_capture.h"
+++++++ #include "raat_plugin_source_selection_test.h"
++++++++#include "raat_plugin_source_selection_mp.h"
+++++++ #include "raat_plugin_transport_test.h"
+++++++ 
+++++++ #if defined(PLATFORM_LINUX) && defined(HAVE_ALSA)
+++++++@@ -72,6 +73,18 @@ void fail(const char *fmt, ...) {
+++++++     exit(1);
+++++++ }
+++++++ 
++++++++void sig_handler(int signo) {
++++++++    /*
++++++++    call with:
++++++++    kill -USR1 {pid}
++++++++    */
++++++++    if (signo == SIGUSR1) {
++++++++        printf("received SIGUSR1\n");
++++++++    } else {
++++++++        printf("OOPS: KEW\n");
++++++++    }
++++++++}
++++++++
+++++++ void usage(void) {
+++++++     fprintf(stderr, "USAGE: raat_app <configfile>\n");
+++++++     fprintf(stderr, "\n");
+++++++@@ -248,7 +261,16 @@ int main(int argc, char **argv) {
+++++++         if (!strcmp(type, "test")) {
+++++++             status = RAAT__test_source_selection_plugin_new(RC__ALLOCATOR_DEFAULT, device, source_selection, &source_selection_plugin);
+++++++             if (!RC__STATUS_IS_SUCCESS(status)) { rcfail(status, "failed to initialize test source_selection"); }
+++++++-
++++++++        } else if (!strcmp(type, "mp")) {
++++++++
++++++++            if(signal(SIGUSR1, sig_handler) == SIG_ERR) {
++++++++                RAAT__TRACE("[source_selection/mp] ERROR signal(SIGUSR1, sig_handler) == SIG_ERR");
++++++++            } else {
++++++++                RAAT__TRACE("[source_selection/mp] signal(SIGUSR1, sig_handler) == SIG_ERR");
++++++++            }
++++++++            
++++++++            status = RAAT__mp_source_selection_plugin_new(RC__ALLOCATOR_DEFAULT, device, source_selection, &source_selection_plugin, );
++++++++            if (!RC__STATUS_IS_SUCCESS(status)) { rcfail(status, "failed to initialize MP source_selection"); }
+++++++         } else {
+++++++             if (type == NULL) fail("Invalid config %s: unknown source_selection type '%s'", type);
+++++++         }
++++++diff --git a/plugins/build.mk b/plugins/build.mk
++++++index b22ce82..499a18a 100644
++++++--- a/plugins/build.mk
+++++++++ b/plugins/build.mk
++++++@@ -32,6 +32,14 @@ raat_source_selection_test_SOURCES  := raat_plugin_source_selection_test.c
++++++ 
++++++ $(eval $(call BUILD_STATICLIB,raat_source_selection_test))
++++++ 
+++++++#
+++++++# source_selection_mp plugin
+++++++#
+++++++raat_source_selection_mp_DEPS     := raat
+++++++raat_source_selection_mp_SOURCES  := raat_plugin_source_selection_mp.c
+++++++
+++++++$(eval $(call BUILD_STATICLIB,raat_source_selection_mp))
+++++++
++++++ #
++++++ # volume_dummy plugin
++++++ #
++++++diff --git a/plugins/raat_plugin_source_selection_mp.c b/plugins/raat_plugin_source_selection_mp.c
++++++new file mode 100644
++++++index 0000000..cb472b9
++++++--- /dev/null
+++++++++ b/plugins/raat_plugin_source_selection_mp.c
++++++@@ -0,0 +1,139 @@
+++++++//
+++++++// The contents of this file are subject to RAAT SDK License
+++++++// agreement; You may not use this file except in compliance
+++++++// with the License.
+++++++//
+++++++// Copyright (C) 2015 Roon Labs LLC
+++++++//
+++++++// All Rights Reserved.
+++++++//
+++++++#include "raat_plugin_source_selection_mp.h"
+++++++#include "rc_list.h"
+++++++
+++++++#include <uv.h>
+++++++
+++++++#include <stdio.h>
+++++++#include <stdlib.h>
+++++++#include <signal.h>
+++++++#include <unistd.h>
+++++++
+++++++#define RAAT__CURRENT_LOG self->log
+++++++
+++++++static RC__Status sig_handler(void *vself) {
+++++++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
+++++++    json_t *reason = json_object();
+++++++    json_object_set_new(reason, "reason", json_string("source_deselected"));
+++++++    self->output->force_teardown(self->output, reason);
+++++++    json_decref(reason);
+++++++}
+++++++
+++++++static RC__Status source_selection_add_state_listener(void *vself, RAAT__SourceSelectionStateCallback cb, void *userdata) {
+++++++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
+++++++    return RAAT__source_selection_state_listeners_add(&self->state_listeners, cb, userdata);
+++++++}
+++++++
+++++++static RC__Status source_selection_remove_state_listener(void *vself, RAAT__SourceSelectionStateCallback cb, void *userdata) {
+++++++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
+++++++    return RAAT__source_selection_state_listeners_remove(&self->state_listeners, cb, userdata);
+++++++}
+++++++
+++++++static RC__Status source_selection_get_info(void *vself, json_t **out_info) {
+++++++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
+++++++
+++++++    RC__ASSERT(self);
+++++++    RC__ASSERT(out_info);
+++++++
+++++++    json_incref(self->info);
+++++++    *out_info = self->info;
+++++++
+++++++    return RC__STATUS_SUCCESS;
+++++++}
+++++++
+++++++static RC__Status source_selection_get_state(void *vself, RAAT__SourceSelectionState *out_state) {
+++++++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
+++++++
+++++++    RC__ASSERT(self != NULL);
+++++++    RC__ASSERT(out_state != NULL);
+++++++
+++++++    out_state->status   = self->status;
+++++++
+++++++    return RC__STATUS_SUCCESS;
+++++++}
+++++++
+++++++static void source_selection_request_source(void *vself, RAAT__SourceSelectionRequestSourceCallback cb, void *cb_userdata) {
+++++++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
+++++++
+++++++    RAAT__TRACE("[source_selection/mp] requesting source");
+++++++    RC__ASSERT(self);
+++++++    RAAT__TRACE("[source_selection/mp] source acquired");
+++++++
+++++++    json_t *config = json_object_get(self->info, "config");
+++++++    const char *source_selection_command = json_string_value(json_object_get(config, "source_selection_command"));
+++++++    RAAT__TRACE("[source_selection/mp] source_selection_command: %s", source_selection_command);
+++++++
+++++++    RAAT__TRACE("[source_selection/mp] pre /opt/roon/sourceselect");
+++++++    system(source_selection_command);
+++++++    RAAT__TRACE("[source_selection/mp] post /opt/roon/sourceselect");
+++++++
+++++++    self->status = RAAT__SOURCE_SELECTION_STATUS_SELECTED; 
+++++++    RAAT__SourceSelectionState state = {0,};
+++++++    state.status = self->status;
+++++++    RAAT__source_selection_state_listeners_invoke(&self->state_listeners, &state);
+++++++
+++++++    cb(cb_userdata, RC__STATUS_SUCCESS, NULL);
+++++++}
+++++++
+++++++static void source_selection_request_standby(void *vself, RAAT__SourceSelectionRequestSourceCallback cb, void *cb_userdata) {
+++++++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
+++++++
+++++++    RAAT__TRACE("[source_selection/mp] requesting standby");
+++++++    RC__ASSERT(self);
+++++++
+++++++    RAAT__TRACE("[source_selection/mp] in standby");
+++++++
+++++++    self->status = RAAT__SOURCE_SELECTION_STATUS_STANDBY; 
+++++++    RAAT__SourceSelectionState state = {0,};
+++++++    state.status = self->status;
+++++++    RAAT__source_selection_state_listeners_invoke(&self->state_listeners, &state);
+++++++
+++++++    cb(cb_userdata, RC__STATUS_SUCCESS, NULL);
+++++++}
+++++++
+++++++RC__Status 
+++++++RAAT__mp_source_selection_plugin_new(RC__Allocator *alloc, RAAT__Device *device, json_t *config, RAAT__SourceSelectionPlugin **out_source_selection) { 
+++++++    alloc = RC__allocator_default(alloc);
+++++++    MPSourceSelectionPlugin *self      = RC__new0(alloc, MPSourceSelectionPlugin, 1);
+++++++    if (self == NULL) return RC__STATUS_OUT_OF_MEMORY;
+++++++    self->alloc                        = alloc;
+++++++    self->log                          = RAAT__device_get_log(device);
+++++++    self->plugin.get_info              = source_selection_get_info;
+++++++    self->plugin.add_state_listener    = source_selection_add_state_listener;
+++++++    self->plugin.remove_state_listener = source_selection_remove_state_listener;
+++++++    self->plugin.get_state             = source_selection_get_state;
+++++++    self->plugin.request_source        = source_selection_request_source;
+++++++    self->plugin.request_standby       = source_selection_request_standby;
+++++++    self->status                       = RAAT__SOURCE_SELECTION_STATUS_STANDBY;
+++++++    self->output                       = RAAT__device_get_output_plugin(device);
+++++++
+++++++    uv_mutex_init(&self->lock);
+++++++    RAAT__source_selection_state_listeners_init(&self->state_listeners, self->alloc);
+++++++
+++++++    self->info = json_object();
+++++++    json_object_set(self->info, "config", config);
+++++++
+++++++    RAAT__TRACE("[source_selection/mp] initialized");
+++++++
+++++++    *out_source_selection = &self->plugin;
+++++++    return RC__STATUS_SUCCESS;
+++++++}
+++++++
+++++++void
+++++++RAAT__mp_source_selection_plugin_delete(RAAT__SourceSelectionPlugin *source_selection) {
+++++++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)source_selection;
+++++++    uv_mutex_destroy(&self->lock);
+++++++    if (self->info) json_decref(self->info);
+++++++    RAAT__source_selection_state_listeners_destroy(&self->state_listeners);
+++++++    RC__free(self->alloc, self);
+++++++}
+++++++
+++++++
++++++diff --git a/plugins/raat_plugin_source_selection_mp.h b/plugins/raat_plugin_source_selection_mp.h
++++++new file mode 100644
++++++index 0000000..98643be
++++++--- /dev/null
+++++++++ b/plugins/raat_plugin_source_selection_mp.h
++++++@@ -0,0 +1,53 @@
+++++++//
+++++++// The contents of this file are subject to RAAT SDK License
+++++++// agreement; You may not use this file except in compliance
+++++++// with the License.
+++++++//
+++++++// Copyright (C) 2015 Roon Labs LLC
+++++++//
+++++++// All Rights Reserved.
+++++++//
+++++++#ifndef INCLUDED_RAAT_PLUGIN_SOURCE_SELECTION_MP_H
+++++++#define INCLUDED_RAAT_PLUGIN_SOURCE_SELECTION_MP_H
+++++++
+++++++#include "rc_base.h"
+++++++#include "rc_allocator.h"
+++++++#include "rc_status.h"
+++++++#include "raat_fwd.h"
+++++++#include "raat_device.h"
+++++++#include "raat_plugin_source_selection.h"
+++++++#include "raat_plugin_output.h"
+++++++#include <stdlib.h>
+++++++#include <signal.h>
+++++++#include <unistd.h>
+++++++#include <jansson.h>
+++++++
+++++++#ifdef __cplusplus
+++++++extern "C" {
+++++++#endif
+++++++
+++++++/*
+++++++ * SourceSelection Plugin
+++++++ */
+++++++typedef struct {
+++++++    RAAT__SourceSelectionPlugin          plugin;          // must be first item in struct
+++++++    uv_mutex_t                           lock;
+++++++    RC__Allocator                       *alloc;
+++++++    RAAT__SourceSelectionStateListeners  state_listeners;
+++++++    RAAT__Log                           *log;
+++++++    RAAT__SourceSelectionStatus          status;
+++++++    RAAT__OutputPlugin                  *output;
+++++++    json_t                              *info;
+++++++    __sighandler_t                      (*sig_handler)();
+++++++} MPSourceSelectionPlugin;
+++++++
+++++++RC__Status
+++++++RAAT__mp_source_selection_plugin_new(RC__Allocator *alloc, RAAT__Device *device, json_t *config, RAAT__SourceSelectionPlugin **out_source_selection); 
+++++++void
+++++++RAAT__mp_source_selection_plugin_delete(RAAT__SourceSelectionPlugin *out_source_selection);
+++++++
+++++++#ifdef __cplusplus
+++++++}
+++++++#endif
+++++++
+++++++#endif
++++++diff --git a/plugins/raat_plugin_source_selection_test.c b/plugins/raat_plugin_source_selection_test.c
++++++index ae54153..a51e10c 100644
++++++--- a/plugins/raat_plugin_source_selection_test.c
+++++++++ b/plugins/raat_plugin_source_selection_test.c
++++++@@ -12,6 +12,9 @@
++++++ 
++++++ #include <uv.h>
++++++ 
+++++++#include <stdio.h>
+++++++#include <stdlib.h>
+++++++
++++++ #define RAAT__CURRENT_LOG self->log
++++++ 
++++++ /*
++++++diff --git a/raat_app/build.mk b/raat_app/build.mk
++++++index f989bbd..6113577 100644
++++++--- a/raat_app/build.mk
+++++++++ b/raat_app/build.mk
++++++@@ -8,6 +8,7 @@ raat_app_DEPS    = raat	\
++++++ 		   raat_output_null \
++++++ 		   raat_output_capture \
++++++ 		   raat_source_selection_test \
+++++++		   raat_source_selection_mp \
++++++ 		   raat_volume_dummy \
++++++ 		   raat_volume_incremental \
++++++ 		   raat_volume_software \
++++++diff --git a/raat_app/raat_app.c b/raat_app/raat_app.c
++++++index 4763626..eb582cc 100644
++++++--- a/raat_app/raat_app.c
+++++++++ b/raat_app/raat_app.c
++++++@@ -24,6 +24,7 @@
++++++ #include "raat_plugin_output_null.h"
++++++ #include "raat_plugin_output_capture.h"
++++++ #include "raat_plugin_source_selection_test.h"
+++++++#include "raat_plugin_source_selection_mp.h"
++++++ #include "raat_plugin_transport_test.h"
++++++ 
++++++ #if defined(PLATFORM_LINUX) && defined(HAVE_ALSA)
++++++@@ -46,6 +47,8 @@
++++++ #include <stdio.h>
++++++ #include <stdarg.h>
++++++ #include <string.h>
+++++++#include <signal.h>
+++++++#include <unistd.h>
++++++ 
++++++ #include <jansson.h>
++++++ 
++++++@@ -248,7 +251,15 @@ int main(int argc, char **argv) {
++++++         if (!strcmp(type, "test")) {
++++++             status = RAAT__test_source_selection_plugin_new(RC__ALLOCATOR_DEFAULT, device, source_selection, &source_selection_plugin);
++++++             if (!RC__STATUS_IS_SUCCESS(status)) { rcfail(status, "failed to initialize test source_selection"); }
++++++-
+++++++        } else if (!strcmp(type, "mp")) {
+++++++            status = RAAT__mp_source_selection_plugin_new(RC__ALLOCATOR_DEFAULT, device, source_selection, &source_selection_plugin);
+++++++            MPSourceSelectionPlugin *mp_source = (MPSourceSelectionPlugin*) source_selection_plugin;
+++++++            if(signal(SIGUSR1, mp_source->sig_handler) == SIG_ERR) {
+++++++                RAAT__TRACE("[raat_app source_selection/mp] ERROR SETTING UP");
+++++++            } else {
+++++++                RAAT__TRACE("[raat_app source_selection/mp] SIGNAL SET UP");
+++++++            }
+++++++            if (!RC__STATUS_IS_SUCCESS(status)) { rcfail(status, "failed to initialize MP source_selection"); }
++++++         } else {
++++++             if (type == NULL) fail("Invalid config %s: unknown source_selection type '%s'", type);
++++++         }
+++++diff --git a/plugins/build.mk b/plugins/build.mk
+++++index b22ce82..499a18a 100644
+++++--- a/plugins/build.mk
++++++++ b/plugins/build.mk
+++++@@ -32,6 +32,14 @@ raat_source_selection_test_SOURCES  := raat_plugin_source_selection_test.c
+++++ 
+++++ $(eval $(call BUILD_STATICLIB,raat_source_selection_test))
+++++ 
++++++#
++++++# source_selection_mp plugin
++++++#
++++++raat_source_selection_mp_DEPS     := raat
++++++raat_source_selection_mp_SOURCES  := raat_plugin_source_selection_mp.c
++++++
++++++$(eval $(call BUILD_STATICLIB,raat_source_selection_mp))
++++++
+++++ #
+++++ # volume_dummy plugin
+++++ #
+++++diff --git a/plugins/raat_plugin_source_selection_mp.c b/plugins/raat_plugin_source_selection_mp.c
+++++new file mode 100644
+++++index 0000000..1eb50fd
+++++--- /dev/null
++++++++ b/plugins/raat_plugin_source_selection_mp.c
+++++@@ -0,0 +1,173 @@
++++++//
++++++// The contents of this file are subject to RAAT SDK License
++++++// agreement; You may not use this file except in compliance
++++++// with the License.
++++++//
++++++// Copyright (C) 2015 Roon Labs LLC
++++++//
++++++// All Rights Reserved.
++++++//
++++++#include "raat_plugin_source_selection_mp.h"
++++++#include "rc_list.h"
++++++
++++++#include <uv.h>
++++++
++++++#include <stdio.h>
++++++#include <stdlib.h>
++++++#include <signal.h>
++++++#include <unistd.h>
++++++#include <sys/stat.h>
++++++#include <fcntl.h>
++++++#include <limits.h>
++++++#include <pthread.h>
++++++
++++++#define RAAT__CURRENT_LOG self->log
++++++#define PIPE_BUF 1024
++++++#define MY_FIFO "/opt/roon/fifo"
++++++
++++++static RC__Status sig_handler(void *vself) {
++++++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
++++++    json_t *reason = json_object();
++++++    json_object_set_new(reason, "reason", json_string("source_deselected"));
++++++    self->output->force_teardown(self->output, reason);
++++++    json_decref(reason);
++++++}
++++++
++++++void read_loop(void *vself)
++++++{
++++++	int fd;
++++++	size_t len;
++++++    mkfifo(MY_FIFO, 0666);
++++++	char buf[PIPE_BUF];
++++++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
++++++    printf("ENTER READ_LOOP");
++++++	while (1) {
++++++        printf("START WHILE LOOP");
++++++		fd = open(MY_FIFO, O_RDONLY);
++++++		read(fd, buf, PIPE_BUF);
++++++        printf("Received: %s\n", buf);
++++++        if(buf=="A") {
++++++            json_t *reason = json_object();
++++++            json_object_set_new(reason, "reason", json_string("source_deselected"));
++++++            self->output->force_teardown(self->output, reason);
++++++            json_decref(reason);
++++++        }
++++++        close(fd);                 
++++++    };
++++++}
++++++
++++++static RC__Status source_selection_add_state_listener(void *vself, RAAT__SourceSelectionStateCallback cb, void *userdata) {
++++++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
++++++    return RAAT__source_selection_state_listeners_add(&self->state_listeners, cb, userdata);
++++++}
++++++
++++++static RC__Status source_selection_remove_state_listener(void *vself, RAAT__SourceSelectionStateCallback cb, void *userdata) {
++++++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
++++++    return RAAT__source_selection_state_listeners_remove(&self->state_listeners, cb, userdata);
++++++}
++++++
++++++static RC__Status source_selection_get_info(void *vself, json_t **out_info) {
++++++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
++++++
++++++    RC__ASSERT(self);
++++++    RC__ASSERT(out_info);
++++++
++++++    json_incref(self->info);
++++++    *out_info = self->info;
++++++
++++++    return RC__STATUS_SUCCESS;
++++++}
++++++
++++++static RC__Status source_selection_get_state(void *vself, RAAT__SourceSelectionState *out_state) {
++++++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
++++++
++++++    RC__ASSERT(self != NULL);
++++++    RC__ASSERT(out_state != NULL);
++++++
++++++    out_state->status   = self->status;
++++++
++++++    return RC__STATUS_SUCCESS;
++++++}
++++++
++++++static void source_selection_request_source(void *vself, RAAT__SourceSelectionRequestSourceCallback cb, void *cb_userdata) {
++++++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
++++++
++++++    RAAT__TRACE("[source_selection/mp] requesting source");
++++++    RC__ASSERT(self);
++++++    RAAT__TRACE("[source_selection/mp] source acquired");
++++++
++++++    json_t *config = json_object_get(self->info, "config");
++++++    const char *source_selection_command = json_string_value(json_object_get(config, "source_selection_command"));
++++++    RAAT__TRACE("[source_selection/mp] source_selection_command: %s", source_selection_command);
++++++
++++++    RAAT__TRACE("[source_selection/mp] pre /opt/roon/sourceselect");
++++++    system(source_selection_command);
++++++    RAAT__TRACE("[source_selection/mp] post /opt/roon/sourceselect");
++++++
++++++    self->status = RAAT__SOURCE_SELECTION_STATUS_SELECTED; 
++++++    RAAT__SourceSelectionState state = {0,};
++++++    state.status = self->status;
++++++    RAAT__source_selection_state_listeners_invoke(&self->state_listeners, &state);
++++++
++++++    cb(cb_userdata, RC__STATUS_SUCCESS, NULL);
++++++}
++++++
++++++static void source_selection_request_standby(void *vself, RAAT__SourceSelectionRequestSourceCallback cb, void *cb_userdata) {
++++++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
++++++
++++++    RAAT__TRACE("[source_selection/mp] requesting standby");
++++++    RC__ASSERT(self);
++++++
++++++    RAAT__TRACE("[source_selection/mp] in standby");
++++++
++++++    self->status = RAAT__SOURCE_SELECTION_STATUS_STANDBY; 
++++++    RAAT__SourceSelectionState state = {0,};
++++++    state.status = self->status;
++++++    RAAT__source_selection_state_listeners_invoke(&self->state_listeners, &state);
++++++
++++++    cb(cb_userdata, RC__STATUS_SUCCESS, NULL);
++++++}
++++++
++++++RC__Status 
++++++RAAT__mp_source_selection_plugin_new(RC__Allocator *alloc, RAAT__Device *device, json_t *config, RAAT__SourceSelectionPlugin **out_source_selection) { 
++++++    alloc = RC__allocator_default(alloc);
++++++    pthread_t pid;
++++++    MPSourceSelectionPlugin *self      = RC__new0(alloc, MPSourceSelectionPlugin, 1);
++++++    if (self == NULL) return RC__STATUS_OUT_OF_MEMORY;
++++++    self->alloc                        = alloc;
++++++    self->log                          = RAAT__device_get_log(device);
++++++    self->plugin.get_info              = source_selection_get_info;
++++++    self->plugin.add_state_listener    = source_selection_add_state_listener;
++++++    self->plugin.remove_state_listener = source_selection_remove_state_listener;
++++++    self->plugin.get_state             = source_selection_get_state;
++++++    self->plugin.request_source        = source_selection_request_source;
++++++    self->plugin.request_standby       = source_selection_request_standby;
++++++    self->status                       = RAAT__SOURCE_SELECTION_STATUS_STANDBY;
++++++    self->output                       = RAAT__device_get_output_plugin(device);
++++++
++++++    uv_mutex_init(&self->lock);
++++++    RAAT__source_selection_state_listeners_init(&self->state_listeners, self->alloc);
++++++
++++++    self->info = json_object();
++++++    json_object_set(self->info, "config", config);
++++++
++++++    RAAT__TRACE("[source_selection/mp] initialized");
++++++
++++++    *out_source_selection = &self->plugin;
++++++
++++++    pthread_create(&pid, 0, read_loop, &self);
++++++
++++++    return RC__STATUS_SUCCESS;
++++++}
++++++
++++++void
++++++RAAT__mp_source_selection_plugin_delete(RAAT__SourceSelectionPlugin *source_selection) {
++++++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)source_selection;
++++++    unlink(MY_FIFO);
++++++    uv_mutex_destroy(&self->lock);
++++++    if (self->info) json_decref(self->info);
++++++    RAAT__source_selection_state_listeners_destroy(&self->state_listeners);
++++++    RC__free(self->alloc, self);
++++++}
++++++
++++++
+++++diff --git a/plugins/raat_plugin_source_selection_mp.h b/plugins/raat_plugin_source_selection_mp.h
+++++new file mode 100644
+++++index 0000000..98643be
+++++--- /dev/null
++++++++ b/plugins/raat_plugin_source_selection_mp.h
+++++@@ -0,0 +1,53 @@
++++++//
++++++// The contents of this file are subject to RAAT SDK License
++++++// agreement; You may not use this file except in compliance
++++++// with the License.
++++++//
++++++// Copyright (C) 2015 Roon Labs LLC
++++++//
++++++// All Rights Reserved.
++++++//
++++++#ifndef INCLUDED_RAAT_PLUGIN_SOURCE_SELECTION_MP_H
++++++#define INCLUDED_RAAT_PLUGIN_SOURCE_SELECTION_MP_H
++++++
++++++#include "rc_base.h"
++++++#include "rc_allocator.h"
++++++#include "rc_status.h"
++++++#include "raat_fwd.h"
++++++#include "raat_device.h"
++++++#include "raat_plugin_source_selection.h"
++++++#include "raat_plugin_output.h"
++++++#include <stdlib.h>
++++++#include <signal.h>
++++++#include <unistd.h>
++++++#include <jansson.h>
++++++
++++++#ifdef __cplusplus
++++++extern "C" {
++++++#endif
++++++
++++++/*
++++++ * SourceSelection Plugin
++++++ */
++++++typedef struct {
++++++    RAAT__SourceSelectionPlugin          plugin;          // must be first item in struct
++++++    uv_mutex_t                           lock;
++++++    RC__Allocator                       *alloc;
++++++    RAAT__SourceSelectionStateListeners  state_listeners;
++++++    RAAT__Log                           *log;
++++++    RAAT__SourceSelectionStatus          status;
++++++    RAAT__OutputPlugin                  *output;
++++++    json_t                              *info;
++++++    __sighandler_t                      (*sig_handler)();
++++++} MPSourceSelectionPlugin;
++++++
++++++RC__Status
++++++RAAT__mp_source_selection_plugin_new(RC__Allocator *alloc, RAAT__Device *device, json_t *config, RAAT__SourceSelectionPlugin **out_source_selection); 
++++++void
++++++RAAT__mp_source_selection_plugin_delete(RAAT__SourceSelectionPlugin *out_source_selection);
++++++
++++++#ifdef __cplusplus
++++++}
++++++#endif
++++++
++++++#endif
+++++diff --git a/plugins/raat_plugin_source_selection_test.c b/plugins/raat_plugin_source_selection_test.c
+++++index ae54153..a51e10c 100644
+++++--- a/plugins/raat_plugin_source_selection_test.c
++++++++ b/plugins/raat_plugin_source_selection_test.c
+++++@@ -12,6 +12,9 @@
+++++ 
+++++ #include <uv.h>
+++++ 
++++++#include <stdio.h>
++++++#include <stdlib.h>
++++++
+++++ #define RAAT__CURRENT_LOG self->log
+++++ 
+++++ /*
+++++diff --git a/raat_app/build.mk b/raat_app/build.mk
+++++index f989bbd..6113577 100644
+++++--- a/raat_app/build.mk
++++++++ b/raat_app/build.mk
+++++@@ -8,6 +8,7 @@ raat_app_DEPS    = raat	\
+++++ 		   raat_output_null \
+++++ 		   raat_output_capture \
+++++ 		   raat_source_selection_test \
++++++		   raat_source_selection_mp \
+++++ 		   raat_volume_dummy \
+++++ 		   raat_volume_incremental \
+++++ 		   raat_volume_software \
+++++diff --git a/raat_app/raat_app.c b/raat_app/raat_app.c
+++++index 4763626..033f471 100644
+++++--- a/raat_app/raat_app.c
++++++++ b/raat_app/raat_app.c
+++++@@ -24,6 +24,7 @@
+++++ #include "raat_plugin_output_null.h"
+++++ #include "raat_plugin_output_capture.h"
+++++ #include "raat_plugin_source_selection_test.h"
++++++#include "raat_plugin_source_selection_mp.h"
+++++ #include "raat_plugin_transport_test.h"
+++++ 
+++++ #if defined(PLATFORM_LINUX) && defined(HAVE_ALSA)
+++++@@ -46,6 +47,8 @@
+++++ #include <stdio.h>
+++++ #include <stdarg.h>
+++++ #include <string.h>
++++++#include <signal.h>
++++++#include <unistd.h>
+++++ 
+++++ #include <jansson.h>
+++++ 
+++++@@ -248,7 +251,18 @@ int main(int argc, char **argv) {
+++++         if (!strcmp(type, "test")) {
+++++             status = RAAT__test_source_selection_plugin_new(RC__ALLOCATOR_DEFAULT, device, source_selection, &source_selection_plugin);
+++++             if (!RC__STATUS_IS_SUCCESS(status)) { rcfail(status, "failed to initialize test source_selection"); }
+++++-
++++++        } else if (!strcmp(type, "mp")) {
++++++            status = RAAT__mp_source_selection_plugin_new(RC__ALLOCATOR_DEFAULT, device, source_selection, &source_selection_plugin);
++++++            /*
++++++            MPSourceSelectionPlugin *mp_source = (MPSourceSelectionPlugin*) source_selection_plugin;
++++++            mp_source
++++++            if(signal(SIGUSR1, mp_source->sig_handler) == SIG_ERR) {
++++++                RAAT__TRACE("[raat_app source_selection/mp] ERROR SETTING UP");
++++++            } else {
++++++                RAAT__TRACE("[raat_app source_selection/mp] SIGNAL SET UP");
++++++            }
++++++            */
++++++            if (!RC__STATUS_IS_SUCCESS(status)) { rcfail(status, "failed to initialize MP source_selection"); }
+++++         } else {
+++++             if (type == NULL) fail("Invalid config %s: unknown source_selection type '%s'", type);
+++++         }
++++diff --git a/plugins/build.mk b/plugins/build.mk
++++index b22ce82..499a18a 100644
++++--- a/plugins/build.mk
+++++++ b/plugins/build.mk
++++@@ -32,6 +32,14 @@ raat_source_selection_test_SOURCES  := raat_plugin_source_selection_test.c
++++ 
++++ $(eval $(call BUILD_STATICLIB,raat_source_selection_test))
++++ 
+++++#
+++++# source_selection_mp plugin
+++++#
+++++raat_source_selection_mp_DEPS     := raat
+++++raat_source_selection_mp_SOURCES  := raat_plugin_source_selection_mp.c
+++++
+++++$(eval $(call BUILD_STATICLIB,raat_source_selection_mp))
+++++
++++ #
++++ # volume_dummy plugin
++++ #
++++diff --git a/plugins/raat_plugin_source_selection_mp.c b/plugins/raat_plugin_source_selection_mp.c
++++new file mode 100644
++++index 0000000..87ac352
++++--- /dev/null
+++++++ b/plugins/raat_plugin_source_selection_mp.c
++++@@ -0,0 +1,176 @@
+++++//
+++++// The contents of this file are subject to RAAT SDK License
+++++// agreement; You may not use this file except in compliance
+++++// with the License.
+++++//
+++++// Copyright (C) 2015 Roon Labs LLC
+++++//
+++++// All Rights Reserved.
+++++//
+++++#include "raat_plugin_source_selection_mp.h"
+++++#include "rc_list.h"
+++++
+++++#include <uv.h>
+++++
+++++#include <stdio.h>
+++++#include <stdlib.h>
+++++#include <signal.h>
+++++#include <unistd.h>
+++++#include <sys/stat.h>
+++++#include <fcntl.h>
+++++#include <limits.h>
+++++#include <pthread.h>
+++++
+++++#define RAAT__CURRENT_LOG self->log
+++++#define PIPE_BUF 64
+++++#define MY_FIFO "/opt/roon/fifo"
+++++
+++++static RC__Status sig_handler(void *vself) {
+++++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
+++++    json_t *reason = json_object();
+++++    json_object_set_new(reason, "reason", json_string("source_deselected"));
+++++    self->output->force_teardown(self->output, reason);
+++++    json_decref(reason);
+++++}
+++++
+++++void read_loop(void *vself)
+++++{
+++++	int fd;
+++++	size_t len;
+++++    mkfifo(MY_FIFO, 0666);
+++++	char buf[PIPE_BUF];
+++++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
+++++    printf("ENTER READ_LOOP");
+++++	while (1) {
+++++        printf("START WHILE LOOP");
+++++		fd = open(MY_FIFO, O_RDONLY);
+++++		read(fd, buf, PIPE_BUF);
+++++        printf("Received: %s\n", buf);
+++++        if(buf=="A") {
+++++            printf("IN buf==A IF");
+++++            json_t *reason = json_object();
+++++            json_object_set_new(reason, "reason", json_string("source_deselected"));
+++++            self->output->force_teardown(self->output, reason);
+++++            json_decref(reason);
+++++        } else {
+++++            printf("?? buf != A");
+++++        }
+++++        close(fd);                 
+++++    };
+++++}
+++++
+++++static RC__Status source_selection_add_state_listener(void *vself, RAAT__SourceSelectionStateCallback cb, void *userdata) {
+++++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
+++++    return RAAT__source_selection_state_listeners_add(&self->state_listeners, cb, userdata);
+++++}
+++++
+++++static RC__Status source_selection_remove_state_listener(void *vself, RAAT__SourceSelectionStateCallback cb, void *userdata) {
+++++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
+++++    return RAAT__source_selection_state_listeners_remove(&self->state_listeners, cb, userdata);
+++++}
+++++
+++++static RC__Status source_selection_get_info(void *vself, json_t **out_info) {
+++++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
+++++
+++++    RC__ASSERT(self);
+++++    RC__ASSERT(out_info);
+++++
+++++    json_incref(self->info);
+++++    *out_info = self->info;
+++++
+++++    return RC__STATUS_SUCCESS;
+++++}
+++++
+++++static RC__Status source_selection_get_state(void *vself, RAAT__SourceSelectionState *out_state) {
+++++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
+++++
+++++    RC__ASSERT(self != NULL);
+++++    RC__ASSERT(out_state != NULL);
+++++
+++++    out_state->status   = self->status;
+++++
+++++    return RC__STATUS_SUCCESS;
+++++}
+++++
+++++static void source_selection_request_source(void *vself, RAAT__SourceSelectionRequestSourceCallback cb, void *cb_userdata) {
+++++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
+++++
+++++    RAAT__TRACE("[source_selection/mp] requesting source");
+++++    RC__ASSERT(self);
+++++    RAAT__TRACE("[source_selection/mp] source acquired");
+++++
+++++    json_t *config = json_object_get(self->info, "config");
+++++    const char *source_selection_command = json_string_value(json_object_get(config, "source_selection_command"));
+++++    RAAT__TRACE("[source_selection/mp] source_selection_command: %s", source_selection_command);
+++++
+++++    RAAT__TRACE("[source_selection/mp] pre /opt/roon/sourceselect");
+++++    system(source_selection_command);
+++++    RAAT__TRACE("[source_selection/mp] post /opt/roon/sourceselect");
+++++
+++++    self->status = RAAT__SOURCE_SELECTION_STATUS_SELECTED; 
+++++    RAAT__SourceSelectionState state = {0,};
+++++    state.status = self->status;
+++++    RAAT__source_selection_state_listeners_invoke(&self->state_listeners, &state);
+++++
+++++    cb(cb_userdata, RC__STATUS_SUCCESS, NULL);
+++++}
+++++
+++++static void source_selection_request_standby(void *vself, RAAT__SourceSelectionRequestSourceCallback cb, void *cb_userdata) {
+++++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
+++++
+++++    RAAT__TRACE("[source_selection/mp] requesting standby");
+++++    RC__ASSERT(self);
+++++
+++++    RAAT__TRACE("[source_selection/mp] in standby");
+++++
+++++    self->status = RAAT__SOURCE_SELECTION_STATUS_STANDBY; 
+++++    RAAT__SourceSelectionState state = {0,};
+++++    state.status = self->status;
+++++    RAAT__source_selection_state_listeners_invoke(&self->state_listeners, &state);
+++++
+++++    cb(cb_userdata, RC__STATUS_SUCCESS, NULL);
+++++}
+++++
+++++RC__Status 
+++++RAAT__mp_source_selection_plugin_new(RC__Allocator *alloc, RAAT__Device *device, json_t *config, RAAT__SourceSelectionPlugin **out_source_selection) { 
+++++    alloc = RC__allocator_default(alloc);
+++++    pthread_t pid;
+++++    MPSourceSelectionPlugin *self      = RC__new0(alloc, MPSourceSelectionPlugin, 1);
+++++    if (self == NULL) return RC__STATUS_OUT_OF_MEMORY;
+++++    self->alloc                        = alloc;
+++++    self->log                          = RAAT__device_get_log(device);
+++++    self->plugin.get_info              = source_selection_get_info;
+++++    self->plugin.add_state_listener    = source_selection_add_state_listener;
+++++    self->plugin.remove_state_listener = source_selection_remove_state_listener;
+++++    self->plugin.get_state             = source_selection_get_state;
+++++    self->plugin.request_source        = source_selection_request_source;
+++++    self->plugin.request_standby       = source_selection_request_standby;
+++++    self->status                       = RAAT__SOURCE_SELECTION_STATUS_STANDBY;
+++++    self->output                       = RAAT__device_get_output_plugin(device);
+++++
+++++    uv_mutex_init(&self->lock);
+++++    RAAT__source_selection_state_listeners_init(&self->state_listeners, self->alloc);
+++++
+++++    self->info = json_object();
+++++    json_object_set(self->info, "config", config);
+++++
+++++    RAAT__TRACE("[source_selection/mp] initialized");
+++++
+++++    *out_source_selection = &self->plugin;
+++++
+++++    pthread_create(&pid, 0, read_loop, &self);
+++++
+++++    return RC__STATUS_SUCCESS;
+++++}
+++++
+++++void
+++++RAAT__mp_source_selection_plugin_delete(RAAT__SourceSelectionPlugin *source_selection) {
+++++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)source_selection;
+++++    unlink(MY_FIFO);
+++++    uv_mutex_destroy(&self->lock);
+++++    if (self->info) json_decref(self->info);
+++++    RAAT__source_selection_state_listeners_destroy(&self->state_listeners);
+++++    RC__free(self->alloc, self);
+++++}
+++++
+++++
++++diff --git a/plugins/raat_plugin_source_selection_mp.h b/plugins/raat_plugin_source_selection_mp.h
++++new file mode 100644
++++index 0000000..98643be
++++--- /dev/null
+++++++ b/plugins/raat_plugin_source_selection_mp.h
++++@@ -0,0 +1,53 @@
+++++//
+++++// The contents of this file are subject to RAAT SDK License
+++++// agreement; You may not use this file except in compliance
+++++// with the License.
+++++//
+++++// Copyright (C) 2015 Roon Labs LLC
+++++//
+++++// All Rights Reserved.
+++++//
+++++#ifndef INCLUDED_RAAT_PLUGIN_SOURCE_SELECTION_MP_H
+++++#define INCLUDED_RAAT_PLUGIN_SOURCE_SELECTION_MP_H
+++++
+++++#include "rc_base.h"
+++++#include "rc_allocator.h"
+++++#include "rc_status.h"
+++++#include "raat_fwd.h"
+++++#include "raat_device.h"
+++++#include "raat_plugin_source_selection.h"
+++++#include "raat_plugin_output.h"
+++++#include <stdlib.h>
+++++#include <signal.h>
+++++#include <unistd.h>
+++++#include <jansson.h>
+++++
+++++#ifdef __cplusplus
+++++extern "C" {
+++++#endif
+++++
+++++/*
+++++ * SourceSelection Plugin
+++++ */
+++++typedef struct {
+++++    RAAT__SourceSelectionPlugin          plugin;          // must be first item in struct
+++++    uv_mutex_t                           lock;
+++++    RC__Allocator                       *alloc;
+++++    RAAT__SourceSelectionStateListeners  state_listeners;
+++++    RAAT__Log                           *log;
+++++    RAAT__SourceSelectionStatus          status;
+++++    RAAT__OutputPlugin                  *output;
+++++    json_t                              *info;
+++++    __sighandler_t                      (*sig_handler)();
+++++} MPSourceSelectionPlugin;
+++++
+++++RC__Status
+++++RAAT__mp_source_selection_plugin_new(RC__Allocator *alloc, RAAT__Device *device, json_t *config, RAAT__SourceSelectionPlugin **out_source_selection); 
+++++void
+++++RAAT__mp_source_selection_plugin_delete(RAAT__SourceSelectionPlugin *out_source_selection);
+++++
+++++#ifdef __cplusplus
+++++}
+++++#endif
+++++
+++++#endif
++++diff --git a/plugins/raat_plugin_source_selection_test.c b/plugins/raat_plugin_source_selection_test.c
++++index ae54153..a51e10c 100644
++++--- a/plugins/raat_plugin_source_selection_test.c
+++++++ b/plugins/raat_plugin_source_selection_test.c
++++@@ -12,6 +12,9 @@
++++ 
++++ #include <uv.h>
++++ 
+++++#include <stdio.h>
+++++#include <stdlib.h>
+++++
++++ #define RAAT__CURRENT_LOG self->log
++++ 
++++ /*
++++diff --git a/raat_app/build.mk b/raat_app/build.mk
++++index f989bbd..6113577 100644
++++--- a/raat_app/build.mk
+++++++ b/raat_app/build.mk
++++@@ -8,6 +8,7 @@ raat_app_DEPS    = raat	\
++++ 		   raat_output_null \
++++ 		   raat_output_capture \
++++ 		   raat_source_selection_test \
+++++		   raat_source_selection_mp \
++++ 		   raat_volume_dummy \
++++ 		   raat_volume_incremental \
++++ 		   raat_volume_software \
++++diff --git a/raat_app/raat_app.c b/raat_app/raat_app.c
++++index 4763626..033f471 100644
++++--- a/raat_app/raat_app.c
+++++++ b/raat_app/raat_app.c
++++@@ -24,6 +24,7 @@
++++ #include "raat_plugin_output_null.h"
++++ #include "raat_plugin_output_capture.h"
++++ #include "raat_plugin_source_selection_test.h"
+++++#include "raat_plugin_source_selection_mp.h"
++++ #include "raat_plugin_transport_test.h"
++++ 
++++ #if defined(PLATFORM_LINUX) && defined(HAVE_ALSA)
++++@@ -46,6 +47,8 @@
++++ #include <stdio.h>
++++ #include <stdarg.h>
++++ #include <string.h>
+++++#include <signal.h>
+++++#include <unistd.h>
++++ 
++++ #include <jansson.h>
++++ 
++++@@ -248,7 +251,18 @@ int main(int argc, char **argv) {
++++         if (!strcmp(type, "test")) {
++++             status = RAAT__test_source_selection_plugin_new(RC__ALLOCATOR_DEFAULT, device, source_selection, &source_selection_plugin);
++++             if (!RC__STATUS_IS_SUCCESS(status)) { rcfail(status, "failed to initialize test source_selection"); }
++++-
+++++        } else if (!strcmp(type, "mp")) {
+++++            status = RAAT__mp_source_selection_plugin_new(RC__ALLOCATOR_DEFAULT, device, source_selection, &source_selection_plugin);
+++++            /*
+++++            MPSourceSelectionPlugin *mp_source = (MPSourceSelectionPlugin*) source_selection_plugin;
+++++            mp_source
+++++            if(signal(SIGUSR1, mp_source->sig_handler) == SIG_ERR) {
+++++                RAAT__TRACE("[raat_app source_selection/mp] ERROR SETTING UP");
+++++            } else {
+++++                RAAT__TRACE("[raat_app source_selection/mp] SIGNAL SET UP");
+++++            }
+++++            */
+++++            if (!RC__STATUS_IS_SUCCESS(status)) { rcfail(status, "failed to initialize MP source_selection"); }
++++         } else {
++++             if (type == NULL) fail("Invalid config %s: unknown source_selection type '%s'", type);
++++         }
+++diff --git a/plugins/build.mk b/plugins/build.mk
+++index b22ce82..499a18a 100644
+++--- a/plugins/build.mk
++++++ b/plugins/build.mk
+++@@ -32,6 +32,14 @@ raat_source_selection_test_SOURCES  := raat_plugin_source_selection_test.c
+++ 
+++ $(eval $(call BUILD_STATICLIB,raat_source_selection_test))
+++ 
++++#
++++# source_selection_mp plugin
++++#
++++raat_source_selection_mp_DEPS     := raat
++++raat_source_selection_mp_SOURCES  := raat_plugin_source_selection_mp.c
++++
++++$(eval $(call BUILD_STATICLIB,raat_source_selection_mp))
++++
+++ #
+++ # volume_dummy plugin
+++ #
+++diff --git a/plugins/raat_plugin_source_selection_mp.c b/plugins/raat_plugin_source_selection_mp.c
+++new file mode 100644
+++index 0000000..88ee8ef
+++--- /dev/null
++++++ b/plugins/raat_plugin_source_selection_mp.c
+++@@ -0,0 +1,175 @@
++++//
++++// The contents of this file are subject to RAAT SDK License
++++// agreement; You may not use this file except in compliance
++++// with the License.
++++//
++++// Copyright (C) 2015 Roon Labs LLC
++++//
++++// All Rights Reserved.
++++//
++++#include "raat_plugin_source_selection_mp.h"
++++#include "rc_list.h"
++++
++++#include <uv.h>
++++
++++#include <stdio.h>
++++#include <stdlib.h>
++++#include <signal.h>
++++#include <unistd.h>
++++#include <sys/stat.h>
++++#include <fcntl.h>
++++#include <limits.h>
++++#include <pthread.h>
++++
++++#define RAAT__CURRENT_LOG self->log
++++#define MY_FIFO "/opt/roon/fifo"
++++
++++static RC__Status sig_handler(void *vself) {
++++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
++++    json_t *reason = json_object();
++++    json_object_set_new(reason, "reason", json_string("source_deselected"));
++++    self->output->force_teardown(self->output, reason);
++++    json_decref(reason);
++++}
++++
++++void * read_loop(void *vself)
++++{
++++	int fd;
++++	size_t len;
++++    mkfifo(MY_FIFO, 0666);
++++	char buf[64];
++++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
++++    printf("ENTER READ_LOOP");
++++	while (1) {
++++        printf("START WHILE LOOP");
++++		fd = open(MY_FIFO, O_RDONLY);
++++		read(fd, buf, 64);
++++        printf("Received: %s\n", buf);
++++        if(buf=="A") {
++++            printf("IN buf==A IF");
++++            json_t *reason = json_object();
++++            json_object_set_new(reason, "reason", json_string("source_deselected"));
++++            self->output->force_teardown(self->output, reason);
++++            json_decref(reason);
++++        } else {
++++            printf("?? buf != A");
++++        }
++++        close(fd);                 
++++    };
++++}
++++
++++static RC__Status source_selection_add_state_listener(void *vself, RAAT__SourceSelectionStateCallback cb, void *userdata) {
++++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
++++    return RAAT__source_selection_state_listeners_add(&self->state_listeners, cb, userdata);
++++}
++++
++++static RC__Status source_selection_remove_state_listener(void *vself, RAAT__SourceSelectionStateCallback cb, void *userdata) {
++++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
++++    return RAAT__source_selection_state_listeners_remove(&self->state_listeners, cb, userdata);
++++}
++++
++++static RC__Status source_selection_get_info(void *vself, json_t **out_info) {
++++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
++++
++++    RC__ASSERT(self);
++++    RC__ASSERT(out_info);
++++
++++    json_incref(self->info);
++++    *out_info = self->info;
++++
++++    return RC__STATUS_SUCCESS;
++++}
++++
++++static RC__Status source_selection_get_state(void *vself, RAAT__SourceSelectionState *out_state) {
++++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
++++
++++    RC__ASSERT(self != NULL);
++++    RC__ASSERT(out_state != NULL);
++++
++++    out_state->status   = self->status;
++++
++++    return RC__STATUS_SUCCESS;
++++}
++++
++++static void source_selection_request_source(void *vself, RAAT__SourceSelectionRequestSourceCallback cb, void *cb_userdata) {
++++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
++++
++++    RAAT__TRACE("[source_selection/mp] requesting source");
++++    RC__ASSERT(self);
++++    RAAT__TRACE("[source_selection/mp] source acquired");
++++
++++    json_t *config = json_object_get(self->info, "config");
++++    const char *source_selection_command = json_string_value(json_object_get(config, "source_selection_command"));
++++    RAAT__TRACE("[source_selection/mp] source_selection_command: %s", source_selection_command);
++++
++++    RAAT__TRACE("[source_selection/mp] pre /opt/roon/sourceselect");
++++    system(source_selection_command);
++++    RAAT__TRACE("[source_selection/mp] post /opt/roon/sourceselect");
++++
++++    self->status = RAAT__SOURCE_SELECTION_STATUS_SELECTED; 
++++    RAAT__SourceSelectionState state = {0,};
++++    state.status = self->status;
++++    RAAT__source_selection_state_listeners_invoke(&self->state_listeners, &state);
++++
++++    cb(cb_userdata, RC__STATUS_SUCCESS, NULL);
++++}
++++
++++static void source_selection_request_standby(void *vself, RAAT__SourceSelectionRequestSourceCallback cb, void *cb_userdata) {
++++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
++++
++++    RAAT__TRACE("[source_selection/mp] requesting standby");
++++    RC__ASSERT(self);
++++
++++    RAAT__TRACE("[source_selection/mp] in standby");
++++
++++    self->status = RAAT__SOURCE_SELECTION_STATUS_STANDBY; 
++++    RAAT__SourceSelectionState state = {0,};
++++    state.status = self->status;
++++    RAAT__source_selection_state_listeners_invoke(&self->state_listeners, &state);
++++
++++    cb(cb_userdata, RC__STATUS_SUCCESS, NULL);
++++}
++++
++++RC__Status 
++++RAAT__mp_source_selection_plugin_new(RC__Allocator *alloc, RAAT__Device *device, json_t *config, RAAT__SourceSelectionPlugin **out_source_selection) { 
++++    alloc = RC__allocator_default(alloc);
++++    pthread_t pid;
++++    MPSourceSelectionPlugin *self      = RC__new0(alloc, MPSourceSelectionPlugin, 1);
++++    if (self == NULL) return RC__STATUS_OUT_OF_MEMORY;
++++    self->alloc                        = alloc;
++++    self->log                          = RAAT__device_get_log(device);
++++    self->plugin.get_info              = source_selection_get_info;
++++    self->plugin.add_state_listener    = source_selection_add_state_listener;
++++    self->plugin.remove_state_listener = source_selection_remove_state_listener;
++++    self->plugin.get_state             = source_selection_get_state;
++++    self->plugin.request_source        = source_selection_request_source;
++++    self->plugin.request_standby       = source_selection_request_standby;
++++    self->status                       = RAAT__SOURCE_SELECTION_STATUS_STANDBY;
++++    self->output                       = RAAT__device_get_output_plugin(device);
++++
++++    uv_mutex_init(&self->lock);
++++    RAAT__source_selection_state_listeners_init(&self->state_listeners, self->alloc);
++++
++++    self->info = json_object();
++++    json_object_set(self->info, "config", config);
++++
++++    RAAT__TRACE("[source_selection/mp] initialized");
++++
++++    *out_source_selection = &self->plugin;
++++
++++    pthread_create(&pid, 0, read_loop, &self);
++++
++++    return RC__STATUS_SUCCESS;
++++}
++++
++++void
++++RAAT__mp_source_selection_plugin_delete(RAAT__SourceSelectionPlugin *source_selection) {
++++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)source_selection;
++++    unlink(MY_FIFO);
++++    uv_mutex_destroy(&self->lock);
++++    if (self->info) json_decref(self->info);
++++    RAAT__source_selection_state_listeners_destroy(&self->state_listeners);
++++    RC__free(self->alloc, self);
++++}
++++
++++
+++diff --git a/plugins/raat_plugin_source_selection_mp.h b/plugins/raat_plugin_source_selection_mp.h
+++new file mode 100644
+++index 0000000..98643be
+++--- /dev/null
++++++ b/plugins/raat_plugin_source_selection_mp.h
+++@@ -0,0 +1,53 @@
++++//
++++// The contents of this file are subject to RAAT SDK License
++++// agreement; You may not use this file except in compliance
++++// with the License.
++++//
++++// Copyright (C) 2015 Roon Labs LLC
++++//
++++// All Rights Reserved.
++++//
++++#ifndef INCLUDED_RAAT_PLUGIN_SOURCE_SELECTION_MP_H
++++#define INCLUDED_RAAT_PLUGIN_SOURCE_SELECTION_MP_H
++++
++++#include "rc_base.h"
++++#include "rc_allocator.h"
++++#include "rc_status.h"
++++#include "raat_fwd.h"
++++#include "raat_device.h"
++++#include "raat_plugin_source_selection.h"
++++#include "raat_plugin_output.h"
++++#include <stdlib.h>
++++#include <signal.h>
++++#include <unistd.h>
++++#include <jansson.h>
++++
++++#ifdef __cplusplus
++++extern "C" {
++++#endif
++++
++++/*
++++ * SourceSelection Plugin
++++ */
++++typedef struct {
++++    RAAT__SourceSelectionPlugin          plugin;          // must be first item in struct
++++    uv_mutex_t                           lock;
++++    RC__Allocator                       *alloc;
++++    RAAT__SourceSelectionStateListeners  state_listeners;
++++    RAAT__Log                           *log;
++++    RAAT__SourceSelectionStatus          status;
++++    RAAT__OutputPlugin                  *output;
++++    json_t                              *info;
++++    __sighandler_t                      (*sig_handler)();
++++} MPSourceSelectionPlugin;
++++
++++RC__Status
++++RAAT__mp_source_selection_plugin_new(RC__Allocator *alloc, RAAT__Device *device, json_t *config, RAAT__SourceSelectionPlugin **out_source_selection); 
++++void
++++RAAT__mp_source_selection_plugin_delete(RAAT__SourceSelectionPlugin *out_source_selection);
++++
++++#ifdef __cplusplus
++++}
++++#endif
++++
++++#endif
+++diff --git a/plugins/raat_plugin_source_selection_test.c b/plugins/raat_plugin_source_selection_test.c
+++index ae54153..a51e10c 100644
+++--- a/plugins/raat_plugin_source_selection_test.c
++++++ b/plugins/raat_plugin_source_selection_test.c
+++@@ -12,6 +12,9 @@
+++ 
+++ #include <uv.h>
+++ 
++++#include <stdio.h>
++++#include <stdlib.h>
++++
+++ #define RAAT__CURRENT_LOG self->log
+++ 
+++ /*
+++diff --git a/raat_app/build.mk b/raat_app/build.mk
+++index f989bbd..6113577 100644
+++--- a/raat_app/build.mk
++++++ b/raat_app/build.mk
+++@@ -8,6 +8,7 @@ raat_app_DEPS    = raat	\
+++ 		   raat_output_null \
+++ 		   raat_output_capture \
+++ 		   raat_source_selection_test \
++++		   raat_source_selection_mp \
+++ 		   raat_volume_dummy \
+++ 		   raat_volume_incremental \
+++ 		   raat_volume_software \
+++diff --git a/raat_app/raat_app.c b/raat_app/raat_app.c
+++index 4763626..033f471 100644
+++--- a/raat_app/raat_app.c
++++++ b/raat_app/raat_app.c
+++@@ -24,6 +24,7 @@
+++ #include "raat_plugin_output_null.h"
+++ #include "raat_plugin_output_capture.h"
+++ #include "raat_plugin_source_selection_test.h"
++++#include "raat_plugin_source_selection_mp.h"
+++ #include "raat_plugin_transport_test.h"
+++ 
+++ #if defined(PLATFORM_LINUX) && defined(HAVE_ALSA)
+++@@ -46,6 +47,8 @@
+++ #include <stdio.h>
+++ #include <stdarg.h>
+++ #include <string.h>
++++#include <signal.h>
++++#include <unistd.h>
+++ 
+++ #include <jansson.h>
+++ 
+++@@ -248,7 +251,18 @@ int main(int argc, char **argv) {
+++         if (!strcmp(type, "test")) {
+++             status = RAAT__test_source_selection_plugin_new(RC__ALLOCATOR_DEFAULT, device, source_selection, &source_selection_plugin);
+++             if (!RC__STATUS_IS_SUCCESS(status)) { rcfail(status, "failed to initialize test source_selection"); }
+++-
++++        } else if (!strcmp(type, "mp")) {
++++            status = RAAT__mp_source_selection_plugin_new(RC__ALLOCATOR_DEFAULT, device, source_selection, &source_selection_plugin);
++++            /*
++++            MPSourceSelectionPlugin *mp_source = (MPSourceSelectionPlugin*) source_selection_plugin;
++++            mp_source
++++            if(signal(SIGUSR1, mp_source->sig_handler) == SIG_ERR) {
++++                RAAT__TRACE("[raat_app source_selection/mp] ERROR SETTING UP");
++++            } else {
++++                RAAT__TRACE("[raat_app source_selection/mp] SIGNAL SET UP");
++++            }
++++            */
++++            if (!RC__STATUS_IS_SUCCESS(status)) { rcfail(status, "failed to initialize MP source_selection"); }
+++         } else {
+++             if (type == NULL) fail("Invalid config %s: unknown source_selection type '%s'", type);
+++         }
++diff --git a/plugins/build.mk b/plugins/build.mk
++index b22ce82..499a18a 100644
++--- a/plugins/build.mk
+++++ b/plugins/build.mk
++@@ -32,6 +32,14 @@ raat_source_selection_test_SOURCES  := raat_plugin_source_selection_test.c
++ 
++ $(eval $(call BUILD_STATICLIB,raat_source_selection_test))
++ 
+++#
+++# source_selection_mp plugin
+++#
+++raat_source_selection_mp_DEPS     := raat
+++raat_source_selection_mp_SOURCES  := raat_plugin_source_selection_mp.c
+++
+++$(eval $(call BUILD_STATICLIB,raat_source_selection_mp))
+++
++ #
++ # volume_dummy plugin
++ #
++diff --git a/plugins/raat_plugin_source_selection_mp.c b/plugins/raat_plugin_source_selection_mp.c
++new file mode 100644
++index 0000000..73cc475
++--- /dev/null
+++++ b/plugins/raat_plugin_source_selection_mp.c
++@@ -0,0 +1,178 @@
+++//
+++// The contents of this file are subject to RAAT SDK License
+++// agreement; You may not use this file except in compliance
+++// with the License.
+++//
+++// Copyright (C) 2015 Roon Labs LLC
+++//
+++// All Rights Reserved.
+++//
+++#include "raat_plugin_source_selection_mp.h"
+++#include "rc_list.h"
+++
+++#include <uv.h>
+++
+++#include <stdio.h>
+++#include <stdlib.h>
+++#include <signal.h>
+++#include <unistd.h>
+++#include <sys/stat.h>
+++#include <fcntl.h>
+++#include <limits.h>
+++#include <pthread.h>
+++
+++#define RAAT__CURRENT_LOG self->log
+++#define MY_FIFO "/opt/roon/fifo"
+++
+++static RC__Status sig_handler(void *vself) {
+++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
+++    json_t *reason = json_object();
+++    json_object_set_new(reason, "reason", json_string("source_deselected"));
+++    self->output->force_teardown(self->output, reason);
+++    json_decref(reason);
+++}
+++
+++void *read_loop(void *vself)
+++{
+++	int fd;
+++	size_t len;
+++    mkfifo(MY_FIFO, 0666);
+++	char buf[64];
+++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
+++    printf("ENTER READ_LOOP\n");
+++    
+++    json_t *config = json_object_get(self->info, "config");
+++    const char *source_selection_command = json_string_value(json_object_get(config, "source_selection_command"));
+++    printf(" READ LOOP FOUND: %s\n", source_selection_command);
+++    RAAT__TRACE(" READ LOOP FOUND: %s", source_selection_command);
+++
+++	while (1) {
+++        printf("START WHILE LOOP \n");
+++		fd = open(MY_FIFO, O_RDONLY);
+++		read(fd, buf, 64);
+++        printf("Received: %s\n", buf);
+++        
+++        json_t *reason = json_object();
+++        json_object_set_new(reason, "reason", json_string("source_deselected"));
+++        self->output->force_teardown(self->output, reason);
+++        json_decref(reason);
+++        
+++        close(fd);                 
+++    };
+++}
+++
+++static RC__Status source_selection_add_state_listener(void *vself, RAAT__SourceSelectionStateCallback cb, void *userdata) {
+++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
+++    return RAAT__source_selection_state_listeners_add(&self->state_listeners, cb, userdata);
+++}
+++
+++static RC__Status source_selection_remove_state_listener(void *vself, RAAT__SourceSelectionStateCallback cb, void *userdata) {
+++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
+++    return RAAT__source_selection_state_listeners_remove(&self->state_listeners, cb, userdata);
+++}
+++
+++static RC__Status source_selection_get_info(void *vself, json_t **out_info) {
+++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
+++
+++    RC__ASSERT(self);
+++    RC__ASSERT(out_info);
+++
+++    json_incref(self->info);
+++    *out_info = self->info;
+++
+++    return RC__STATUS_SUCCESS;
+++}
+++
+++static RC__Status source_selection_get_state(void *vself, RAAT__SourceSelectionState *out_state) {
+++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
+++
+++    RC__ASSERT(self != NULL);
+++    RC__ASSERT(out_state != NULL);
+++
+++    out_state->status   = self->status;
+++
+++    return RC__STATUS_SUCCESS;
+++}
+++
+++static void source_selection_request_source(void *vself, RAAT__SourceSelectionRequestSourceCallback cb, void *cb_userdata) {
+++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
+++
+++    RAAT__TRACE("[source_selection/mp] requesting source");
+++    RC__ASSERT(self);
+++    RAAT__TRACE("[source_selection/mp] source acquired");
+++
+++    json_t *config = json_object_get(self->info, "config");
+++    const char *source_selection_command = json_string_value(json_object_get(config, "source_selection_command"));
+++    RAAT__TRACE("[source_selection/mp] source_selection_command: %s", source_selection_command);
+++
+++    RAAT__TRACE("[source_selection/mp] pre /opt/roon/sourceselect");
+++    system(source_selection_command);
+++    RAAT__TRACE("[source_selection/mp] post /opt/roon/sourceselect");
+++
+++    self->status = RAAT__SOURCE_SELECTION_STATUS_SELECTED; 
+++    RAAT__SourceSelectionState state = {0,};
+++    state.status = self->status;
+++    RAAT__source_selection_state_listeners_invoke(&self->state_listeners, &state);
+++
+++    cb(cb_userdata, RC__STATUS_SUCCESS, NULL);
+++}
+++
+++static void source_selection_request_standby(void *vself, RAAT__SourceSelectionRequestSourceCallback cb, void *cb_userdata) {
+++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
+++
+++    RAAT__TRACE("[source_selection/mp] requesting standby");
+++    RC__ASSERT(self);
+++
+++    RAAT__TRACE("[source_selection/mp] in standby");
+++
+++    self->status = RAAT__SOURCE_SELECTION_STATUS_STANDBY; 
+++    RAAT__SourceSelectionState state = {0,};
+++    state.status = self->status;
+++    RAAT__source_selection_state_listeners_invoke(&self->state_listeners, &state);
+++
+++    cb(cb_userdata, RC__STATUS_SUCCESS, NULL);
+++}
+++
+++RC__Status 
+++RAAT__mp_source_selection_plugin_new(RC__Allocator *alloc, RAAT__Device *device, json_t *config, RAAT__SourceSelectionPlugin **out_source_selection) { 
+++    alloc = RC__allocator_default(alloc);
+++    pthread_t pid;
+++    MPSourceSelectionPlugin *self      = RC__new0(alloc, MPSourceSelectionPlugin, 1);
+++    if (self == NULL) return RC__STATUS_OUT_OF_MEMORY;
+++    self->alloc                        = alloc;
+++    self->log                          = RAAT__device_get_log(device);
+++    self->plugin.get_info              = source_selection_get_info;
+++    self->plugin.add_state_listener    = source_selection_add_state_listener;
+++    self->plugin.remove_state_listener = source_selection_remove_state_listener;
+++    self->plugin.get_state             = source_selection_get_state;
+++    self->plugin.request_source        = source_selection_request_source;
+++    self->plugin.request_standby       = source_selection_request_standby;
+++    self->status                       = RAAT__SOURCE_SELECTION_STATUS_STANDBY;
+++    self->output                       = RAAT__device_get_output_plugin(device);
+++
+++    uv_mutex_init(&self->lock);
+++    RAAT__source_selection_state_listeners_init(&self->state_listeners, self->alloc);
+++
+++    self->info = json_object();
+++    json_object_set(self->info, "config", config);
+++
+++    RAAT__TRACE("[source_selection/mp] initialized");
+++
+++    *out_source_selection = &self->plugin;
+++
+++    pthread_create(&pid, 0, read_loop, (void *)&self);
+++
+++    return RC__STATUS_SUCCESS;
+++}
+++
+++void
+++RAAT__mp_source_selection_plugin_delete(RAAT__SourceSelectionPlugin *source_selection) {
+++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)source_selection;
+++    unlink(MY_FIFO);
+++    uv_mutex_destroy(&self->lock);
+++    if (self->info) json_decref(self->info);
+++    RAAT__source_selection_state_listeners_destroy(&self->state_listeners);
+++    RC__free(self->alloc, self);
+++}
+++
+++
++diff --git a/plugins/raat_plugin_source_selection_mp.h b/plugins/raat_plugin_source_selection_mp.h
++new file mode 100644
++index 0000000..98643be
++--- /dev/null
+++++ b/plugins/raat_plugin_source_selection_mp.h
++@@ -0,0 +1,53 @@
+++//
+++// The contents of this file are subject to RAAT SDK License
+++// agreement; You may not use this file except in compliance
+++// with the License.
+++//
+++// Copyright (C) 2015 Roon Labs LLC
+++//
+++// All Rights Reserved.
+++//
+++#ifndef INCLUDED_RAAT_PLUGIN_SOURCE_SELECTION_MP_H
+++#define INCLUDED_RAAT_PLUGIN_SOURCE_SELECTION_MP_H
+++
+++#include "rc_base.h"
+++#include "rc_allocator.h"
+++#include "rc_status.h"
+++#include "raat_fwd.h"
+++#include "raat_device.h"
+++#include "raat_plugin_source_selection.h"
+++#include "raat_plugin_output.h"
+++#include <stdlib.h>
+++#include <signal.h>
+++#include <unistd.h>
+++#include <jansson.h>
+++
+++#ifdef __cplusplus
+++extern "C" {
+++#endif
+++
+++/*
+++ * SourceSelection Plugin
+++ */
+++typedef struct {
+++    RAAT__SourceSelectionPlugin          plugin;          // must be first item in struct
+++    uv_mutex_t                           lock;
+++    RC__Allocator                       *alloc;
+++    RAAT__SourceSelectionStateListeners  state_listeners;
+++    RAAT__Log                           *log;
+++    RAAT__SourceSelectionStatus          status;
+++    RAAT__OutputPlugin                  *output;
+++    json_t                              *info;
+++    __sighandler_t                      (*sig_handler)();
+++} MPSourceSelectionPlugin;
+++
+++RC__Status
+++RAAT__mp_source_selection_plugin_new(RC__Allocator *alloc, RAAT__Device *device, json_t *config, RAAT__SourceSelectionPlugin **out_source_selection); 
+++void
+++RAAT__mp_source_selection_plugin_delete(RAAT__SourceSelectionPlugin *out_source_selection);
+++
+++#ifdef __cplusplus
+++}
+++#endif
+++
+++#endif
++diff --git a/plugins/raat_plugin_source_selection_test.c b/plugins/raat_plugin_source_selection_test.c
++index ae54153..a51e10c 100644
++--- a/plugins/raat_plugin_source_selection_test.c
+++++ b/plugins/raat_plugin_source_selection_test.c
++@@ -12,6 +12,9 @@
++ 
++ #include <uv.h>
++ 
+++#include <stdio.h>
+++#include <stdlib.h>
+++
++ #define RAAT__CURRENT_LOG self->log
++ 
++ /*
++diff --git a/raat_app/build.mk b/raat_app/build.mk
++index f989bbd..6113577 100644
++--- a/raat_app/build.mk
+++++ b/raat_app/build.mk
++@@ -8,6 +8,7 @@ raat_app_DEPS    = raat	\
++ 		   raat_output_null \
++ 		   raat_output_capture \
++ 		   raat_source_selection_test \
+++		   raat_source_selection_mp \
++ 		   raat_volume_dummy \
++ 		   raat_volume_incremental \
++ 		   raat_volume_software \
++diff --git a/raat_app/raat_app.c b/raat_app/raat_app.c
++index 4763626..033f471 100644
++--- a/raat_app/raat_app.c
+++++ b/raat_app/raat_app.c
++@@ -24,6 +24,7 @@
++ #include "raat_plugin_output_null.h"
++ #include "raat_plugin_output_capture.h"
++ #include "raat_plugin_source_selection_test.h"
+++#include "raat_plugin_source_selection_mp.h"
++ #include "raat_plugin_transport_test.h"
++ 
++ #if defined(PLATFORM_LINUX) && defined(HAVE_ALSA)
++@@ -46,6 +47,8 @@
++ #include <stdio.h>
++ #include <stdarg.h>
++ #include <string.h>
+++#include <signal.h>
+++#include <unistd.h>
++ 
++ #include <jansson.h>
++ 
++@@ -248,7 +251,18 @@ int main(int argc, char **argv) {
++         if (!strcmp(type, "test")) {
++             status = RAAT__test_source_selection_plugin_new(RC__ALLOCATOR_DEFAULT, device, source_selection, &source_selection_plugin);
++             if (!RC__STATUS_IS_SUCCESS(status)) { rcfail(status, "failed to initialize test source_selection"); }
++-
+++        } else if (!strcmp(type, "mp")) {
+++            status = RAAT__mp_source_selection_plugin_new(RC__ALLOCATOR_DEFAULT, device, source_selection, &source_selection_plugin);
+++            /*
+++            MPSourceSelectionPlugin *mp_source = (MPSourceSelectionPlugin*) source_selection_plugin;
+++            mp_source
+++            if(signal(SIGUSR1, mp_source->sig_handler) == SIG_ERR) {
+++                RAAT__TRACE("[raat_app source_selection/mp] ERROR SETTING UP");
+++            } else {
+++                RAAT__TRACE("[raat_app source_selection/mp] SIGNAL SET UP");
+++            }
+++            */
+++            if (!RC__STATUS_IS_SUCCESS(status)) { rcfail(status, "failed to initialize MP source_selection"); }
++         } else {
++             if (type == NULL) fail("Invalid config %s: unknown source_selection type '%s'", type);
++         }
+diff --git a/plugins/build.mk b/plugins/build.mk
+index b22ce82..499a18a 100644
+--- a/plugins/build.mk
++++ b/plugins/build.mk
+@@ -32,6 +32,14 @@ raat_source_selection_test_SOURCES  := raat_plugin_source_selection_test.c
+ 
+ $(eval $(call BUILD_STATICLIB,raat_source_selection_test))
+ 
++#
++# source_selection_mp plugin
++#
++raat_source_selection_mp_DEPS     := raat
++raat_source_selection_mp_SOURCES  := raat_plugin_source_selection_mp.c
++
++$(eval $(call BUILD_STATICLIB,raat_source_selection_mp))
++
+ #
+ # volume_dummy plugin
+ #
+diff --git a/plugins/raat_plugin_source_selection_mp.c b/plugins/raat_plugin_source_selection_mp.c
+new file mode 100644
+index 0000000..5f886fd
+--- /dev/null
++++ b/plugins/raat_plugin_source_selection_mp.c
+@@ -0,0 +1,174 @@
++//
++// The contents of this file are subject to RAAT SDK License
++// agreement; You may not use this file except in compliance
++// with the License.
++//
++// Copyright (C) 2015 Roon Labs LLC
++//
++// All Rights Reserved.
++//
++#include "raat_plugin_source_selection_mp.h"
++#include "rc_list.h"
++
++#include <uv.h>
++
++#include <stdio.h>
++#include <stdlib.h>
++#include <signal.h>
++#include <unistd.h>
++#include <sys/stat.h>
++#include <fcntl.h>
++#include <limits.h>
++#include <pthread.h>
++
++#define RAAT__CURRENT_LOG self->log
++#define MY_FIFO "/opt/roon/fifo"
++
++static RC__Status sig_handler(void *vself) {
++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
++    json_t *reason = json_object();
++    json_object_set_new(reason, "reason", json_string("source_deselected"));
++    self->output->force_teardown(self->output, reason);
++    json_decref(reason);
++}
++
++void *read_loop(void *vself)
++{
++	int fd;
++	size_t len;
++    mkfifo(MY_FIFO, 0666);
++	char buf[64];
++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
++    printf("ENTER READ_LOOP\n");
++    printf("    VAL: %s\n", self->lock.__size);
++    
++	while (1) {
++        printf("START WHILE LOOP \n");
++		fd = open(MY_FIFO, O_RDONLY);
++		read(fd, buf, 64);
++        printf("Received: %s\n", buf);
++        
++        json_t *reason = json_object();
++        json_object_set_new(reason, "reason", json_string("source_deselected"));
++        self->output->force_teardown(self->output, reason);
++        json_decref(reason);
++        
++        close(fd);                 
++    };
++}
++
++static RC__Status source_selection_add_state_listener(void *vself, RAAT__SourceSelectionStateCallback cb, void *userdata) {
++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
++    return RAAT__source_selection_state_listeners_add(&self->state_listeners, cb, userdata);
++}
++
++static RC__Status source_selection_remove_state_listener(void *vself, RAAT__SourceSelectionStateCallback cb, void *userdata) {
++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
++    return RAAT__source_selection_state_listeners_remove(&self->state_listeners, cb, userdata);
++}
++
++static RC__Status source_selection_get_info(void *vself, json_t **out_info) {
++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
++
++    RC__ASSERT(self);
++    RC__ASSERT(out_info);
++
++    json_incref(self->info);
++    *out_info = self->info;
++
++    return RC__STATUS_SUCCESS;
++}
++
++static RC__Status source_selection_get_state(void *vself, RAAT__SourceSelectionState *out_state) {
++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
++
++    RC__ASSERT(self != NULL);
++    RC__ASSERT(out_state != NULL);
++
++    out_state->status   = self->status;
++
++    return RC__STATUS_SUCCESS;
++}
++
++static void source_selection_request_source(void *vself, RAAT__SourceSelectionRequestSourceCallback cb, void *cb_userdata) {
++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
++
++    RAAT__TRACE("[source_selection/mp] requesting source");
++    RC__ASSERT(self);
++    RAAT__TRACE("[source_selection/mp] source acquired");
++
++    json_t *config = json_object_get(self->info, "config");
++    const char *source_selection_command = json_string_value(json_object_get(config, "source_selection_command"));
++    RAAT__TRACE("[source_selection/mp] source_selection_command: %s", source_selection_command);
++
++    RAAT__TRACE("[source_selection/mp] pre /opt/roon/sourceselect");
++    system(source_selection_command);
++    RAAT__TRACE("[source_selection/mp] post /opt/roon/sourceselect");
++
++    self->status = RAAT__SOURCE_SELECTION_STATUS_SELECTED; 
++    RAAT__SourceSelectionState state = {0,};
++    state.status = self->status;
++    RAAT__source_selection_state_listeners_invoke(&self->state_listeners, &state);
++
++    cb(cb_userdata, RC__STATUS_SUCCESS, NULL);
++}
++
++static void source_selection_request_standby(void *vself, RAAT__SourceSelectionRequestSourceCallback cb, void *cb_userdata) {
++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
++
++    RAAT__TRACE("[source_selection/mp] requesting standby");
++    RC__ASSERT(self);
++
++    RAAT__TRACE("[source_selection/mp] in standby");
++
++    self->status = RAAT__SOURCE_SELECTION_STATUS_STANDBY; 
++    RAAT__SourceSelectionState state = {0,};
++    state.status = self->status;
++    RAAT__source_selection_state_listeners_invoke(&self->state_listeners, &state);
++
++    cb(cb_userdata, RC__STATUS_SUCCESS, NULL);
++}
++
++RC__Status 
++RAAT__mp_source_selection_plugin_new(RC__Allocator *alloc, RAAT__Device *device, json_t *config, RAAT__SourceSelectionPlugin **out_source_selection) { 
++    alloc = RC__allocator_default(alloc);
++    pthread_t pid;
++    MPSourceSelectionPlugin *self      = RC__new0(alloc, MPSourceSelectionPlugin, 1);
++    if (self == NULL) return RC__STATUS_OUT_OF_MEMORY;
++    self->alloc                        = alloc;
++    self->log                          = RAAT__device_get_log(device);
++    self->plugin.get_info              = source_selection_get_info;
++    self->plugin.add_state_listener    = source_selection_add_state_listener;
++    self->plugin.remove_state_listener = source_selection_remove_state_listener;
++    self->plugin.get_state             = source_selection_get_state;
++    self->plugin.request_source        = source_selection_request_source;
++    self->plugin.request_standby       = source_selection_request_standby;
++    self->status                       = RAAT__SOURCE_SELECTION_STATUS_STANDBY;
++    self->output                       = RAAT__device_get_output_plugin(device);
++
++    uv_mutex_init(&self->lock);
++    RAAT__source_selection_state_listeners_init(&self->state_listeners, self->alloc);
++
++    self->info = json_object();
++    json_object_set(self->info, "config", config);
++
++    RAAT__TRACE("[source_selection/mp] initialized");
++
++    *out_source_selection = &self->plugin;
++
++    pthread_create(&pid, 0, read_loop, (void *)&self);
++
++    return RC__STATUS_SUCCESS;
++}
++
++void
++RAAT__mp_source_selection_plugin_delete(RAAT__SourceSelectionPlugin *source_selection) {
++    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)source_selection;
++    unlink(MY_FIFO);
++    uv_mutex_destroy(&self->lock);
++    if (self->info) json_decref(self->info);
++    RAAT__source_selection_state_listeners_destroy(&self->state_listeners);
++    RC__free(self->alloc, self);
++}
++
++
+diff --git a/plugins/raat_plugin_source_selection_mp.h b/plugins/raat_plugin_source_selection_mp.h
+new file mode 100644
+index 0000000..5dbd36e
+--- /dev/null
++++ b/plugins/raat_plugin_source_selection_mp.h
+@@ -0,0 +1,52 @@
++//
++// The contents of this file are subject to RAAT SDK License
++// agreement; You may not use this file except in compliance
++// with the License.
++//
++// Copyright (C) 2015 Roon Labs LLC
++//
++// All Rights Reserved.
++//
++#ifndef INCLUDED_RAAT_PLUGIN_SOURCE_SELECTION_MP_H
++#define INCLUDED_RAAT_PLUGIN_SOURCE_SELECTION_MP_H
++
++#include "rc_base.h"
++#include "rc_allocator.h"
++#include "rc_status.h"
++#include "raat_fwd.h"
++#include "raat_device.h"
++#include "raat_plugin_source_selection.h"
++#include "raat_plugin_output.h"
++#include <stdlib.h>
++#include <signal.h>
++#include <unistd.h>
++#include <jansson.h>
++
++#ifdef __cplusplus
++extern "C" {
++#endif
++
++/*
++ * SourceSelection Plugin
++ */
++typedef struct {
++    RAAT__SourceSelectionPlugin          plugin;          // must be first item in struct
++    uv_mutex_t                           lock;
++    RC__Allocator                       *alloc;
++    RAAT__SourceSelectionStateListeners  state_listeners;
++    RAAT__Log                           *log;
++    RAAT__SourceSelectionStatus          status;
++    RAAT__OutputPlugin                  *output;
++    json_t                              *info;
++} MPSourceSelectionPlugin;
++
++RC__Status
++RAAT__mp_source_selection_plugin_new(RC__Allocator *alloc, RAAT__Device *device, json_t *config, RAAT__SourceSelectionPlugin **out_source_selection); 
++void
++RAAT__mp_source_selection_plugin_delete(RAAT__SourceSelectionPlugin *out_source_selection);
++
++#ifdef __cplusplus
++}
++#endif
++
++#endif
+diff --git a/plugins/raat_plugin_source_selection_test.c b/plugins/raat_plugin_source_selection_test.c
+index ae54153..a51e10c 100644
+--- a/plugins/raat_plugin_source_selection_test.c
++++ b/plugins/raat_plugin_source_selection_test.c
+@@ -12,6 +12,9 @@
+ 
+ #include <uv.h>
+ 
++#include <stdio.h>
++#include <stdlib.h>
++
+ #define RAAT__CURRENT_LOG self->log
+ 
+ /*
+diff --git a/raat_app/build.mk b/raat_app/build.mk
+index f989bbd..6113577 100644
+--- a/raat_app/build.mk
++++ b/raat_app/build.mk
+@@ -8,6 +8,7 @@ raat_app_DEPS    = raat	\
+ 		   raat_output_null \
+ 		   raat_output_capture \
+ 		   raat_source_selection_test \
++		   raat_source_selection_mp \
+ 		   raat_volume_dummy \
+ 		   raat_volume_incremental \
+ 		   raat_volume_software \
+diff --git a/raat_app/raat_app.c b/raat_app/raat_app.c
+index 4763626..033f471 100644
+--- a/raat_app/raat_app.c
++++ b/raat_app/raat_app.c
+@@ -24,6 +24,7 @@
+ #include "raat_plugin_output_null.h"
+ #include "raat_plugin_output_capture.h"
+ #include "raat_plugin_source_selection_test.h"
++#include "raat_plugin_source_selection_mp.h"
+ #include "raat_plugin_transport_test.h"
+ 
+ #if defined(PLATFORM_LINUX) && defined(HAVE_ALSA)
+@@ -46,6 +47,8 @@
+ #include <stdio.h>
+ #include <stdarg.h>
+ #include <string.h>
++#include <signal.h>
++#include <unistd.h>
+ 
+ #include <jansson.h>
+ 
+@@ -248,7 +251,18 @@ int main(int argc, char **argv) {
+         if (!strcmp(type, "test")) {
+             status = RAAT__test_source_selection_plugin_new(RC__ALLOCATOR_DEFAULT, device, source_selection, &source_selection_plugin);
+             if (!RC__STATUS_IS_SUCCESS(status)) { rcfail(status, "failed to initialize test source_selection"); }
+-
++        } else if (!strcmp(type, "mp")) {
++            status = RAAT__mp_source_selection_plugin_new(RC__ALLOCATOR_DEFAULT, device, source_selection, &source_selection_plugin);
++            /*
++            MPSourceSelectionPlugin *mp_source = (MPSourceSelectionPlugin*) source_selection_plugin;
++            mp_source
++            if(signal(SIGUSR1, mp_source->sig_handler) == SIG_ERR) {
++                RAAT__TRACE("[raat_app source_selection/mp] ERROR SETTING UP");
++            } else {
++                RAAT__TRACE("[raat_app source_selection/mp] SIGNAL SET UP");
++            }
++            */
++            if (!RC__STATUS_IS_SUCCESS(status)) { rcfail(status, "failed to initialize MP source_selection"); }
+         } else {
+             if (type == NULL) fail("Invalid config %s: unknown source_selection type '%s'", type);
+         }
diff --git a/plugins/build.mk b/plugins/build.mk
index b22ce82..499a18a 100644
--- a/plugins/build.mk
+++ b/plugins/build.mk
@@ -32,6 +32,14 @@ raat_source_selection_test_SOURCES  := raat_plugin_source_selection_test.c
 
 $(eval $(call BUILD_STATICLIB,raat_source_selection_test))
 
+#
+# source_selection_mp plugin
+#
+raat_source_selection_mp_DEPS     := raat
+raat_source_selection_mp_SOURCES  := raat_plugin_source_selection_mp.c
+
+$(eval $(call BUILD_STATICLIB,raat_source_selection_mp))
+
 #
 # volume_dummy plugin
 #
diff --git a/plugins/raat_plugin_source_selection_mp.c b/plugins/raat_plugin_source_selection_mp.c
new file mode 100644
index 0000000..d822ac7
--- /dev/null
+++ b/plugins/raat_plugin_source_selection_mp.c
@@ -0,0 +1,167 @@
+//
+// The contents of this file are subject to RAAT SDK License
+// agreement; You may not use this file except in compliance
+// with the License.
+//
+// Copyright (C) 2015 Roon Labs LLC
+//
+// All Rights Reserved.
+//
+#include "raat_plugin_source_selection_mp.h"
+#include "rc_list.h"
+
+#include <uv.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <signal.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <limits.h>
+#include <pthread.h>
+
+#define RAAT__CURRENT_LOG self->log
+#define MY_FIFO "/opt/roon/fifo"
+
+void *read_loop(void *vself)
+{
+	int fd;
+	size_t len;
+    mkfifo(MY_FIFO, 0666);
+	char buf[64];
+    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
+    printf("ENTER READ_LOOP\n");
+    printf("    VAL: %s\n", self->lock.__size);
+    
+	while (1) {
+        printf("START WHILE LOOP \n");
+		fd = open(MY_FIFO, O_RDONLY);
+		read(fd, buf, 64);
+        printf("Received: %s\n", buf);
+        
+        json_t *reason = json_object();
+        json_object_set_new(reason, "reason", json_string("source_deselected"));
+        self->output->force_teardown(self->output, reason);
+        json_decref(reason);
+        
+        close(fd);                 
+    };
+}
+
+static RC__Status source_selection_add_state_listener(void *vself, RAAT__SourceSelectionStateCallback cb, void *userdata) {
+    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
+    return RAAT__source_selection_state_listeners_add(&self->state_listeners, cb, userdata);
+}
+
+static RC__Status source_selection_remove_state_listener(void *vself, RAAT__SourceSelectionStateCallback cb, void *userdata) {
+    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
+    return RAAT__source_selection_state_listeners_remove(&self->state_listeners, cb, userdata);
+}
+
+static RC__Status source_selection_get_info(void *vself, json_t **out_info) {
+    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
+
+    RC__ASSERT(self);
+    RC__ASSERT(out_info);
+
+    json_incref(self->info);
+    *out_info = self->info;
+
+    return RC__STATUS_SUCCESS;
+}
+
+static RC__Status source_selection_get_state(void *vself, RAAT__SourceSelectionState *out_state) {
+    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
+
+    RC__ASSERT(self != NULL);
+    RC__ASSERT(out_state != NULL);
+
+    out_state->status   = self->status;
+
+    return RC__STATUS_SUCCESS;
+}
+
+static void source_selection_request_source(void *vself, RAAT__SourceSelectionRequestSourceCallback cb, void *cb_userdata) {
+    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
+
+    RAAT__TRACE("[source_selection/mp] requesting source");
+    RC__ASSERT(self);
+    RAAT__TRACE("[source_selection/mp] source acquired");
+
+    json_t *config = json_object_get(self->info, "config");
+    const char *source_selection_command = json_string_value(json_object_get(config, "source_selection_command"));
+    RAAT__TRACE("[source_selection/mp] source_selection_command: %s", source_selection_command);
+
+    RAAT__TRACE("[source_selection/mp] pre /opt/roon/sourceselect");
+    system(source_selection_command);
+    RAAT__TRACE("[source_selection/mp] post /opt/roon/sourceselect");
+
+    self->status = RAAT__SOURCE_SELECTION_STATUS_SELECTED; 
+    RAAT__SourceSelectionState state = {0,};
+    state.status = self->status;
+    RAAT__source_selection_state_listeners_invoke(&self->state_listeners, &state);
+
+    cb(cb_userdata, RC__STATUS_SUCCESS, NULL);
+}
+
+static void source_selection_request_standby(void *vself, RAAT__SourceSelectionRequestSourceCallback cb, void *cb_userdata) {
+    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)vself;
+
+    RAAT__TRACE("[source_selection/mp] requesting standby");
+    RC__ASSERT(self);
+
+    RAAT__TRACE("[source_selection/mp] in standby");
+
+    self->status = RAAT__SOURCE_SELECTION_STATUS_STANDBY; 
+    RAAT__SourceSelectionState state = {0,};
+    state.status = self->status;
+    RAAT__source_selection_state_listeners_invoke(&self->state_listeners, &state);
+
+    cb(cb_userdata, RC__STATUS_SUCCESS, NULL);
+}
+
+RC__Status 
+RAAT__mp_source_selection_plugin_new(RC__Allocator *alloc, RAAT__Device *device, json_t *config, RAAT__SourceSelectionPlugin **out_source_selection) { 
+    alloc = RC__allocator_default(alloc);
+    MPSourceSelectionPlugin *self      = RC__new0(alloc, MPSourceSelectionPlugin, 1);
+    if (self == NULL) return RC__STATUS_OUT_OF_MEMORY;
+    self->alloc                        = alloc;
+    self->log                          = RAAT__device_get_log(device);
+    self->plugin.get_info              = source_selection_get_info;
+    self->plugin.add_state_listener    = source_selection_add_state_listener;
+    self->plugin.remove_state_listener = source_selection_remove_state_listener;
+    self->plugin.get_state             = source_selection_get_state;
+    self->plugin.request_source        = source_selection_request_source;
+    self->plugin.request_standby       = source_selection_request_standby;
+    self->status                       = RAAT__SOURCE_SELECTION_STATUS_STANDBY;
+    self->output                       = RAAT__device_get_output_plugin(device);
+
+    uv_mutex_init(&self->lock);
+    RAAT__source_selection_state_listeners_init(&self->state_listeners, self->alloc);
+
+    self->info = json_object();
+    json_object_set(self->info, "config", config);
+
+
+    RAAT__TRACE("[source_selection/mp] initialized");
+
+    *out_source_selection = &self->plugin;
+    
+    pthread_t pid;
+    pthread_create(&pid, 0, read_loop, (void *) self);
+
+    return RC__STATUS_SUCCESS;
+}
+
+void
+RAAT__mp_source_selection_plugin_delete(RAAT__SourceSelectionPlugin *source_selection) {
+    MPSourceSelectionPlugin *self = (MPSourceSelectionPlugin*)source_selection;
+    unlink(MY_FIFO);
+    uv_mutex_destroy(&self->lock);
+    if (self->info) json_decref(self->info);
+    RAAT__source_selection_state_listeners_destroy(&self->state_listeners);
+    RC__free(self->alloc, self);
+}
+
+
diff --git a/plugins/raat_plugin_source_selection_mp.h b/plugins/raat_plugin_source_selection_mp.h
new file mode 100644
index 0000000..b793113
--- /dev/null
+++ b/plugins/raat_plugin_source_selection_mp.h
@@ -0,0 +1,53 @@
+//
+// The contents of this file are subject to RAAT SDK License
+// agreement; You may not use this file except in compliance
+// with the License.
+//
+// Copyright (C) 2015 Roon Labs LLC
+//
+// All Rights Reserved.
+//
+#ifndef INCLUDED_RAAT_PLUGIN_SOURCE_SELECTION_MP_H
+#define INCLUDED_RAAT_PLUGIN_SOURCE_SELECTION_MP_H
+
+#include "rc_base.h"
+#include "rc_allocator.h"
+#include "rc_status.h"
+#include "raat_fwd.h"
+#include "raat_device.h"
+#include "raat_plugin_source_selection.h"
+#include "raat_plugin_output.h"
+#include <stdlib.h>
+#include <signal.h>
+#include <unistd.h>
+
+#include <jansson.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * SourceSelection Plugin
+ */
+typedef struct {
+    RAAT__SourceSelectionPlugin          plugin;          // must be first item in struct
+    uv_mutex_t                           lock;
+    RC__Allocator                       *alloc;
+    RAAT__SourceSelectionStateListeners  state_listeners;
+    RAAT__Log                           *log;
+    RAAT__SourceSelectionStatus          status;
+    RAAT__OutputPlugin                  *output;
+    json_t                              *info;
+} MPSourceSelectionPlugin;
+
+RC__Status
+RAAT__mp_source_selection_plugin_new(RC__Allocator *alloc, RAAT__Device *device, json_t *config, RAAT__SourceSelectionPlugin **out_source_selection); 
+void
+RAAT__mp_source_selection_plugin_delete(RAAT__SourceSelectionPlugin *out_source_selection);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/plugins/raat_plugin_source_selection_test.c b/plugins/raat_plugin_source_selection_test.c
index ae54153..a51e10c 100644
--- a/plugins/raat_plugin_source_selection_test.c
+++ b/plugins/raat_plugin_source_selection_test.c
@@ -12,6 +12,9 @@
 
 #include <uv.h>
 
+#include <stdio.h>
+#include <stdlib.h>
+
 #define RAAT__CURRENT_LOG self->log
 
 /*
diff --git a/raat_app/build.mk b/raat_app/build.mk
index f989bbd..6113577 100644
--- a/raat_app/build.mk
+++ b/raat_app/build.mk
@@ -8,6 +8,7 @@ raat_app_DEPS    = raat	\
 		   raat_output_null \
 		   raat_output_capture \
 		   raat_source_selection_test \
+		   raat_source_selection_mp \
 		   raat_volume_dummy \
 		   raat_volume_incremental \
 		   raat_volume_software \
diff --git a/raat_app/raat_app.c b/raat_app/raat_app.c
index 4763626..1a12789 100644
--- a/raat_app/raat_app.c
+++ b/raat_app/raat_app.c
@@ -24,6 +24,7 @@
 #include "raat_plugin_output_null.h"
 #include "raat_plugin_output_capture.h"
 #include "raat_plugin_source_selection_test.h"
+#include "raat_plugin_source_selection_mp.h"
 #include "raat_plugin_transport_test.h"
 
 #if defined(PLATFORM_LINUX) && defined(HAVE_ALSA)
@@ -46,6 +47,8 @@
 #include <stdio.h>
 #include <stdarg.h>
 #include <string.h>
+#include <signal.h>
+#include <unistd.h>
 
 #include <jansson.h>
 
@@ -248,7 +251,9 @@ int main(int argc, char **argv) {
         if (!strcmp(type, "test")) {
             status = RAAT__test_source_selection_plugin_new(RC__ALLOCATOR_DEFAULT, device, source_selection, &source_selection_plugin);
             if (!RC__STATUS_IS_SUCCESS(status)) { rcfail(status, "failed to initialize test source_selection"); }
-
+        } else if (!strcmp(type, "mp")) {
+            status = RAAT__mp_source_selection_plugin_new(RC__ALLOCATOR_DEFAULT, device, source_selection, &source_selection_plugin);
+            if (!RC__STATUS_IS_SUCCESS(status)) { rcfail(status, "failed to initialize MP source_selection"); }
         } else {
             if (type == NULL) fail("Invalid config %s: unknown source_selection type '%s'", type);
         }
